---
timezone: UTC+8
---

# JapserQin

**GitHub ID:** qky190525

**Telegram:** @JapserQin

## Self-introduction

一位Web2、拥有5年经验的Java全栈工程师，工作期间参与过AI集成。目前准备探索Web3行业并深耕其中，希望学习更多知识，加速成长。

## Notes

<!-- Content_START -->
# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->
运行一个基于 qwen-agent 的聊天应用试试  
  
创建项目，页面使用 qwen-agent 自带的 WebUI

![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667007234-img_1.png)

配置项，主要是api\_key 和自定义工具（my\_image\_gen，i\_upper）

![img_2.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667106692-img_2.png)

运行结果

![img_3.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667074362-img_3.png)

i\_upper 工具

![img_4.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667082545-img_4.png)
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->

使用qwen-plus模型  
  
添加联网搜索模式，增加数据的真实性

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-01-1764569084856-img.png)

![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-01-1764569097141-img_1.png)
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-30
<!-- DAILY_CHECKIN_2025-11-30_START -->


一个账户管理所有链上资产  
  
1\. 目标用户：多链DeFi农民，资产分散在5-8条不同链上，厌倦了反复跨链、切换网络、管理无数钱包的资深用户。  
  
2\. 解决的核心痛点：资产碎片化；操作复杂且风险高；收益机会流失，由于操作复杂，用户很难实时将资金调配到当下收益率最高的协议中，错过许多瞬时的优质机会。  
  
3\. 使用方式：用户看到Base链有个新协议收益率很高，检查各链余额，选择资金最多的链跨链到Base，等待确认，在新协议存款授权，完成投资。提取收益时，选择最优位置的资产 → 跨链聚合 → 法币出金。  

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-30-1764502576986-img.png)
<!-- DAILY_CHECKIN_2025-11-30_END -->

# 2025-11-29
<!-- DAILY_CHECKIN_2025-11-29_START -->



合约一旦部署之后，是不可篡改的，那么前期MVP版本的合约功能并不完善，如果需要升级，应该如何实现呢？这就需要用到代理合约，代理模式有以下几种：  
  
1\. 代理模式：使用代理合约将调用委托给实际的功能合约（逻辑合约）。用户与代理合约交互，而代理合约将调用转发给逻辑合约。当需要升级时，可以将代理合约指向新的逻辑合约。  
2\. 钻石模式：也称为EIP-2535，允许合约具有多个逻辑合约，每个逻辑合约负责不同的功能（称为facet）。通过一个钻石合约来管理这些facet，可以添加、替换或删除功能。  
3\. 版本化合约：部署多个版本的合约，并让用户与最新版本的合约交互。但是，这种方式需要迁移状态，可能比较复杂。  
4\. 模块化合约：将功能拆分为多个模块，每个模块是一个独立的合约。通过主合约来调用这些模块，升级时只需替换或添加模块。  
  
代理模式中分为：  
1\. 透明代理：通过代理合约的fallback函数将调用委托给逻辑合约。同时，代理合约本身也有一些管理函数（如升级函数），只有管理员可以调用。为了避免管理员和普通用户的调用冲突，透明代理规定：管理员调用管理函数，而普通用户调用逻辑合约的函数。  
2\. UUPS（Universal Upgradeable Proxy Standard）：  
UUPS是另一种代理模式，它将升级逻辑放在逻辑合约中，而不是代理合约中。这样代理合约更简单，但要求逻辑合约必须实现升级功能。  
  
一般情况应该使用 UUPS 代理，参考 GatewayEVM 等基本用的都是这种，它使用到 @openzeppelin/contracts-upgradeable，继承 Initializable, UUPSUpgradeable  
  
具体逻辑如图：

![proxy.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-29-1764420326309-proxy.png)
<!-- DAILY_CHECKIN_2025-11-29_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->




## ERC20 和 ZRC20

ERC20 不具备跨链，需要桥接和其他协议。ZRC20 为外链资产在 ZetaChain 上的表示，能与Gateway 协同执行跨链提现、消息调用  
  
ERC20 即源码中的 asset 为外链合约地址，ZRC20 地址可由函数 getAllZRC20Tokens 获取，官方文档也有地址列表  
[https://www.zetachain.com/docs/developers/evm/zrc20/](https://www.zetachain.com/docs/developers/evm/zrc20/)

## 通用资产应用场景

一款跨链游戏  
  
游戏道具（NFT）可以在任意链铸造、交易、使用，并能无缝转移到另一条链继续用。  
  
游戏代币（ERC-20）可以在任意链支付手续费、参与治理、在跨链副本中结算奖励。

## 研究一下 Gas 消耗，为什么实践与理论不符合？

对比 memory 和 calldata 的 gas 消耗  
  

![gas_code.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-28-1764330335938-gas_code.png)

  
  
以下是消耗结果：  
  
User{uint8 age; unit256 balance}

|   | calldata | memory |
| --- | --- | --- |
| deploy | 310833 | 280877 |
| addUser | 67199 | 66650 |

User{uint256 age; unit256 balance}  

|   | calldata | memory |
| --- | --- | --- |
| deploy | 267168 | 256684 |
| addUser | 67181 | 66584 |

为什么 calldata 的消耗比 memory 多呢？貌似和理论不符？  
  
首先相比 User 结构体，age 由 unit8 变为 uint256，消耗都降低了，这是为什么？  
  
这得请出我们的大模型来拷打一番，模型是这样解释的：  
\`\`\`text  
calldata 操作：  
\- calldataload 读取 age (32字节，含31字节填充)  
\- calldataload 读取 balance (32字节)  
\- 掩码操作提取 uint8  
\- 存储操作  
  
memory 操作：  
\- mload 读取打包数据 (可能更高效)  
\- 直接存储  
\`\`\`  
1\. 混合类型结构体的部署差异更大  
2\. 相同类型结构体差异较小  
3\. 说明编译器对 memory 版本生成更优化的字节码  
  
1\. calldata 版本强制函数为 external 语义  
2\. memory 版本允许函数作为 public 函数，可能被内部调用  
3\. 外部调用有额外的 ABI 解码开销  
  
然后看下同一结构体下，memory 为什么比 calldata 节省 gas？  
  
// 当调用 addUser 时：  
// calldata 路径：  
// 1. 从 calldata 读取结构体字段  
// 2. 解码 ABI 编码（包含填充）  
// 3. 存储到 mapping  
  
// memory 路径：  
// 1. 参数已经以优化格式存在于内存中  
// 2. 直接存储到 mapping（无需额外解码）  
  
编译器优化：memory 参数允许更多编译器优化  
  
调用语义：public 函数比 external 函数在某些场景更高效  
  
内存访问模式：EVM 对内存访问有更好的优化  
  
ABI 解码开销：calldata 需要严格的 ABI 解码  
  
好吧，虽然不知道它是不是在诓我，但侧面印证了**开发以理论为主，但实际测试比理论规则更重要**！
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->





昨日简单分析了 GatewayEVM 的源码实现，知道了托管合约与 zetaConnector 的作用，  
今日继续分析一下 GatewayZEVM 的源码实现。

首先这个肯定是部署在 ZetaChain 上的核心网关合约，那么它管理的一定是 ZRC20 代币和 ZETA 代币了。  
  
先来研究下 ZRC20 代币的管理部分  
  
GatewayZEVM 的代码，上半部分为 GatewayZEVM.sol 代码，下半部分为 ZRC20.sol 的代码

![deposit.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-27-1764223268436-deposit.png)

  
这个方法应该是外部链上的资产通过跨链桥转移到 ZetaChain，由协议地址调用（这是一个常量地址），zrc20 直接铸造相应数量的代币。  
  
这里我们结合 GatewayEVM 和 GatewayZEVM 两个合约，串起来分析一下 ETH 向 ZetaChian 跨链转移 USDC 的步骤：

![ge_deposit.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-27-1764223286739-ge_deposit.png)

1\. GatewayEVM 将 USDC 从 asset 转移到托管合约，通过 \_transferFromToAssetHandler 函数；  
2\. GatewayEVM 发出 Deposited 事件，其中包含原始的 asset 地址信息；  
3\. ZetaChain 协议监听 GatewayEVM 发出的 Deposited 事件，解析事件数据，获取存款信息（发送者、接收者、金额、资产地址等）  
4\. ZetaChain 协议调用 deposit 方法铸造 USDC:ETH 代币（图一中的方法）  
  
继续研究提现流程，从 ETH 中将 USDC 兑换为 BTC 链中的 BTC：  
  
以太坊侧  
1\. 应该是调用此方法：GatewayEVM.depositAndCall( receiver = UniversalAppOnZeta, amount = usdcAmount, asset = USDC\_ETH\_ADDRESS,  
message = abi.encode(targetZRC20BTC, btcRecipientBytes, true), revertOptions)  
  
ZetaChain 侧（Universal App 合约执行 onCall，从下载的官方 demo hello 中可以看到 onCall 方法）  
1\. onCall(context, zrc20In=USDC.ETH, amountIn, message)  
2\. 解析 message → (targetToken=ZRC20\_BTC, recipient=btcAddrBytes, withdrawFlag=true)  
3\. 估算跨链提现到 Bitcoin 的 gas/执行费： fee = IZRC20(targetToken).withdrawGasFee(recipient) 或 Gateway 提供的费用查询  
4\. 用部分 USDC.ETH 通过 DEX 兑换成 ZRC-20 BTC 的“目的链 gas 代币”所需数量，将剩余的 USDC.ETH 全部换成目标代币 ZRC-20 BTC  
5\. 提现到比特币链：调用 GatewayZEVM.withdraw(receiver, amount, zrc20, revertOptions)，发出事件提交给 ZetaChain 验证器（后续研究）  
  
可以看出跨链操作的主要逻辑还是集中在 GatewayEVM 和 GatewayZEVM 中的，那么Universal App 就是围绕 Gateway 提供的入口/出口方法编排自己的业务逻辑。
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->






# Universal App

部署在 ZetaChain 通用 EVM 上的智能合约，原生连接以太坊、比特币、Solana、BNB Chain 等多条区块链。  
  
既能接收来自任意已连接链的合约调用、消息和代币转账，也能主动向这些链发起合约调用和代币转账，可编排跨链的复杂多步骤交易。  
  
gas 抽象，在 ZetaChain 上均对应为 ZRC-20 代币，用户无需持有目标链气体代币，应用会自动通过兑换 ZRC-20 gas 代币来覆盖手续费。

# Gateway

ZetaChain 生态中连接各区块链与链上 Universal App 的统一交互入口。  
  
不同类型的链对应不同的 Gateway。双向交易支持，处理外部链到 ZetaChain 的入向交易的 Gateway 和处理 ZetaChain 到外部链的出向交易。  
  
下面我们研究下 EVM 链兼容的 Gateway 源码。

## GatewayEVM

部署在 EVM 链上的网关，与 Custody（托管合约）和 zetaConnector（Zeta 连接器）配合管理资产  
  
那么 Custody（托管合约）和 zetaConnector（Zeta 连接器）的作用和区别是什么？  
  
从 \_transferToAssetHandler 函数可以看到，当向 ERC20 代币地址转移资产时，如果代币地址是 Zeta 原生代币，那么它用的是连接器，否则用托管合约。 也就是说，托管合约和连接器处理的 token 不同。 细看方法，托管合约还有白名单机制，而且是向托管合约直接转移资产

![_transferToAssetHandler.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159330741-_transferToAssetHandler.png)

接下来我们看 \_transferFromToAssetHandler 函数，这个函数暂时不支持 ZETA 原生代币的转移，但是 ERC20 代币仍然是由托管合约来管理的。

![_transferFromToAssetHandler.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159350735-_transferFromToAssetHandler.png)

只是多了一个发送者参数，为什么就不支持 ZETA 代币的转移了呢？我们继续看下这两个函数调用的地方，可以发现，  
\_transferToAssetHandler 函数被 deposit 和 depositAndCall 这两个函数调用，其含义是向以太坊代币合约地址存入资金，  
而 \_transferFromToAssetHandler 函数被 executeWithERC20 函数调用，它执行了剩余代币（如果有）的回收操作。  
根据官方文档的说明，也证实了这一说法。

![executeWithERC20.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159366805-executeWithERC20.png)![gateway.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159378183-gateway.png)
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->







# ZetaChain

## ZetaChain CLI 使用

### 参考官方文档创建一个 Universal Contract

```
# 创建 hello 项目
npx zetachain@latest new --project hello

yarn
forge soldeer update

forge build
```

```
# 启动环境
npx zetachain localnet start

# 查看第一个账户地址的私钥
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

# 用第一个账户的私钥部署 hello 项目中的 Universal 合约到本地环境然后获取地址，广播上链
UNIVERSAL=$(forge create Universal \
  --rpc-url http://localhost:8545 \
  --private-key $PRIVATE_KEY \
  --evm-version paris \
  --broadcast \
  --json | jq -r .deployedTo) && echo $UNIVERSAL
0x5bf5b11053e734690269C6B9D438F8C9d48F528A

# 获取 Ethereum 链的 Gateway 地址
GATEWAY_EVM=$(jq -r '.["11155112"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
0x09635F643e140090A9A8Dcd712eD6285858ceBef
```

### 测试

![call.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059008804-call.png)

分析控制台打印

![callPrint.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059092077-callPrint.png)

| 对象 | 地址 |  
|---------|--------------------------------------------|  
| 账户 | 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 |  
| Gateway | 0x09635F643e140090A9A8Dcd712eD6285858ceBef |  
| 通用合约 | 0x5bf5b11053e734690269C6B9D438F8C9d48F528A |

  
入站和出站交易的体现，命令输入后确认交易的 transaction hash 为账户向 Gateway 合约的交易，  
控制台打印的 transactionHash 为 Gateway 合约向链内通用合约的交易  
  
当连接链为EVM兼容链的时候，sender 的值会填充给 senderEVM

## 测试网 RPC、Faucet、Explorer

### RPC

EVM RPC：适合开发调试，无需API Key，适合本地CLI/脚本调用，https://zetachain-athens-evm.blockpi.network/v1/rpc/public  
  
Alchemy等其他第三方RPC：适合高流量场景，需要API Key，稳定性高

### Faucet

通过水龙头获得了测试网 token

![test_token.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059233038-test_token.png)

### Explorer

[https://testnet.zetascan.com/](https://testnet.zetascan.com/)

# Qwen API 调用

## 使用官方平台提供的大模型

申请 API key

## 本地部署大模型

本地部署的好处：定制化和可控性极强。支持对模型进行微调、量化压缩等优化，可接入私有知识库，深度集成到内网 OA 等系统；还能自由调整模型温度、top - p 等参数，适配特定业务场景。  
  
这里我选择 ollama 本地部署 qwen3:8b 大模型，新版 ollama 提供了聊天界面，选择模型会自动帮你安装。以下展示命令操作。  
  
ollama 官网下载地址：https://ollama.com/  
  
ollama 可部署模型列表：https://ollama.com/search  
  
每个模型都支持可训练参数的大小选择，参数越多，模型的学习能力和表达能力更强，但对硬件资源（显存、算力等）的需求也越高。  
  
以我 windows 台式机为例，2060显卡目前部署的是 qwen3:8b，资源刚好够用

![models.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059309611-models.png)

### 下载模型

```
# 下载大模型
ollama pull qwen3:8b
# ollama 会自动下载模型并启动服务（可不 pull 直接 run）
ollama run qwen3:8b
# 查看所有下载的大模型
ollama list
# 查看正在运行的大模型
ollama ps
# 停止运行
ollama stop qwen3:8b
```

![ollama_run.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059360200-ollama_run.png)

### 调用模型API

**需要开启 ollama 访问权限，ollama 端口为 11434**

![expose_ollama.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059430590-expose_ollama.png)

安装 SDK：yarn add openai

编写代码调用 API

![apiCode.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059522879-apiCode.png)![aiResponse.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059546095-aiResponse.png)
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->








# ZetaChain

## 概括和优势

**通用区块链**

-   能够跨区块链生态实现原生连接，同时为非智能合约链带来可编程性；
    
-   包含通用权益证明、通用以太坊虚拟机、通用智能合约；
    
-   旨在降低普通人进入去中心化世界的门槛
    

**对于开发者**

-   链式编排功能，可通过单一智能合约协调多链复杂操作，简化开发过程的同时提供扩展性；
    
-   与以太坊 EVM 完全兼容的 UEVM，降低学习门槛，向前兼容性使应用无需修改代码或重新部署，简化运维；
    
-   无 gas 费的执行环境可以降低开发与部署的成本。
    

**对于普通用户**

-   实现无缝跨链资产交互，操作流程更简洁；
    
-   无 Gas 费执行环境和统一流动性池与验证者托管机制，降低了跨链交易中的双重支付、交易失败等风险；
    
-   随着整合更多新区块链，用于无需切换应用即可享受到一致、便捷的服务。
    

**环境安装**

| 环境 | 版本 |
| --- | --- |
| node -v | v24.11.0 |
| yarn -v | 1.22.22 |
| git -v | git version 2.50.1 |
| jq -V | jq-1.8.1 |
| forge -V | forge 1.4.4-stable |

### 安装 zetachain

```
npm install -g zetachain
zetachain -V
7.4.0 # 版本
```

### 打印所有连接在 ZetaChain 上的链

```
zetachain query chains list
```

![zetachain query chains list.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974134372-zetachain_query_chains_list.png)

Count 指来自该连接链的交易需要经过的确认次数，到达次数后交易才会被 ZetaChain 监测到

为了避免原生链出现**区块重组**或**双重支付**导致的交易失效

### 启动一个本地开发环境

```
npx zetachain localnet start
```

![npx zetachain localnet start.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974200876-npx_zetachain_localnet_start.png)

### Developers 页面  
[https://www.zetachain.com/docs/developers](https://www.zetachain.com/docs/developers)

![developers.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974219512-developers.png)

# Qwen

账号注册

![alibabacloud.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974232744-alibabacloud.png)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
