---
timezone: UTC+8
---

# JapserQin

**GitHub ID:** qky190525

**Telegram:** @JapserQin

## Self-introduction

一位Web2、拥有5年经验的Java全栈工程师，工作期间参与过AI集成。目前准备探索Web3行业并深耕其中，希望学习更多知识，加速成长。

## Notes

<!-- Content_START -->
# 2025-12-07
<!-- DAILY_CHECKIN_2025-12-07_START -->
NFT 盲盒  
  
多链选择几个 NFT 形成资源池  
  
用户每次抽取花费固定U，转成 ZRC20，点击“摇一摇”后从资源池中随机抽取一款 NFT，然后将 NFT 跨给用户
<!-- DAILY_CHECKIN_2025-12-07_END -->

# 2025-12-06
<!-- DAILY_CHECKIN_2025-12-06_START -->

Dify：生产级 Agentic 工作流开发平台

[https://cloud.dify.ai/explore/apps](https://cloud.dify.ai/explore/apps)

进行业务编排工具，每一步可由进行自然语言解析

这里我简单画了下交换货币和购买NFT的图，后面的输出替换为代码执行或http调用可以方便实现操作

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-06-1765025405554-img.png)

测试结果，可以发现获取到了我们要的结构化参数

![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-06-1765025500272-img_1.png)![img_2.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-06-1765025510216-img_2.png)
<!-- DAILY_CHECKIN_2025-12-06_END -->

# 2025-12-05
<!-- DAILY_CHECKIN_2025-12-05_START -->


### 研究一下为大模型创建知识库，获取信息更准确，这里提供 ZetaChain 官网 doc 链接

本地大模型：Ollama + qwen3:8b

本地知识库：AnythingLLM + nomic-embed-text:latest

### 设置模型和知识库

![img4.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-05-1764940631794-img4.png)![img3.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-05-1764940643005-img3.png)

### 上传链接到知识库

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-05-1764940678259-img.png)

### 调用模型

![img2.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-05-1764940696566-img2.png)

### qwen3 给出的参考合约代码

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@zeta-chain/contracts/contracts/UniversalReceiver.sol";
import "@zeta-chain/contracts/contracts/interfaces/IZRC20.sol";

contract Swap is UniversalReceiver, Ownable {
    IUniswapV2Router02 public uniswapRouter;

    constructor(address _uniswapRouter) {
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);
    }

    // 跨链调用入口
    function onUniversalCall(
        address _zrc20,
        uint256 _amount,
        bytes calldata _message
    ) external override {
        require(msg.sender == address(this), "Only Gateway can call");

        // 解码消息
        (address targetToken, bytes memory recipient, bool withdrawFlag) = abi.decode(
            _message,
            (address, bytes, bool)
        );

        // 查询目标链的 gas 费用
        (address gasZRC20, uint256 gasFee) = IZRC20(targetToken).withdrawGasFee();

        // 计算最小输入量（覆盖 gas 费用）
        uint256 minInput = _quoteMinInput(_zrc20, targetToken, gasFee);

        require(_amount >= minInput, "Insufficient input for gas fee");

        // 从输入中分配 gas 费用
        uint256 inputForGas = _swapTokensForExactTokens(
            _zrc20,
            gasFee,
            gasZRC20,
            _amount
        );

        // 剩余部分兑换为目标 token
        uint256 out = _swapExactTokensForTokens(
            _zrc20,
            _amount - inputForGas,
            targetToken
        );

        // 批量批准 Gateway 使用 token
        IZRC20(gasZRC20).approve(address(this), gasFee);
        IZRC20(targetToken).approve(address(this), out);

        // 跨链提现
        if (withdrawFlag) {
            // 调用 Gateway 的 withdraw 方法
            // 注意：需要将 recipient 转换为 bytes32 或其他格式
            // 例如：bytes32 recipient = keccak256(recipient);
            // 然后调用 gateway.withdraw(...)
        } else {
            // 本地转账
            IZRC20(targetToken).transfer(msg.sender, out);
        }
    }

    // 查询最小输入量（Uniswap v2 价格）
    function _quoteMinInput(
        address _inputToken,
        address _targetToken,
        uint256 _gasFee
    ) internal view returns (uint256) {
        // 使用 Uniswap v2 的 getAmountsIn 计算最小输入
        // 示例：调用 uniswapRouter.getAmountsIn(...)
    }

    // 用输入 token 兑换 gas token
    function _swapTokensForExactTokens(
        address _inputToken,
        uint256 _amountIn,
        address _gasToken,
        uint256 _totalAmount
    ) internal returns (uint256) {
        // 使用 Uniswap v2 的 swapExactTokensForTokens
        // 示例：调用 uniswapRouter.swapExactTokensForTokens(...)
    }

    // 兑换剩余部分为目标 token
    function _swapExactTokensForTokens(
        address _inputToken,
        uint256 _amountIn,
        address _targetToken
    ) internal returns (uint256) {
        // 使用 Uniswap v2 的 swapExactTokensForTokens
        // 示例：调用 uniswapRouter.swapExactTokensForTokens(...)
    }

    // 处理跨链失败的回退逻辑
    function onRevert(bytes calldata _revertData) external override {
        // 从 revertData 中提取原始发送者和输入 token
        // 执行退款或重试逻辑
    }
}
```
<!-- DAILY_CHECKIN_2025-12-05_END -->

# 2025-12-04
<!-- DAILY_CHECKIN_2025-12-04_START -->



今天尝试让 qwen-agent 帮助我转账，使用我自己写的一个空投demo，和自己部署的ERC20 Token合约

转账444个token

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-04-1764854255054-img.png)![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-04-1764854290782-img_1.png)
<!-- DAILY_CHECKIN_2025-12-04_END -->

# 2025-12-03
<!-- DAILY_CHECKIN_2025-12-03_START -->




让 agent 能够提取自然语言中的 DeFi 操作

```
import json
import json5
import re
from typing import Any, Dict

from qwen_agent.llm import get_chat_model
from qwen_agent.tools.base import BaseTool, register_tool

import config

@register_tool("parse_swap_intent")
class ParseSwapIntent(BaseTool):
    """
    使用大模型解析交易意图的工具
    完全依赖大模型能力，无硬编码规则
    """
    
    name = "parse_swap_intent"
    description = "解析用户的代币兑换意图，提取链、输入代币、输出代币和数量，返回结构化JSON"
    
    def __init__(self, llm_cfg: Dict[str, Any] = None):
        if llm_cfg is None:
            llm_cfg = config.llm_cfg
        super().__init__(llm_cfg)    
        self.llm = get_chat_model(llm_cfg)
    
    def call(self, params: str, **kwargs) -> Dict:
        """
        核心解析方法：调用大模型解析用户输入
        """
        
        # 1. 构造详细的系统提示词
        system_prompt = self._create_system_prompt()
        
        # 2. 调用大模型
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": params}
        ]
        
        response = self.llm.chat(
            messages=messages,
            stream=False
        )
        
        # 3. 提取并解析大模型的响应
        parsed_result = self._extract_json_from_response(response)
        
        return parsed_result
    
    def _create_system_prompt(self) -> str:
        """创建详细的系统提示词，指导大模型正确解析"""
        return """你是一个专业的区块链交易意图解析器。

你的任务是将用户关于代币兑换的自然语言描述，解析为结构化的JSON格式。

## 输出要求：
你必须输出且仅输出以下JSON格式：
{
    "chain": "网络名称",
    "tokenIn": "输入代币符号",
    "tokenOut": "输出代币符号",
    "amount": "数量字符串"
}

## 字段说明：
1. chain: 区块链网络名称（小写）
   - 支持的网络：base, polygon, ethereum, arbitrum, optimism, avalanche, bsc, solana
   - 如果用户没指定，根据上下文推断，默认："ethereum"
   
2. tokenIn: 要卖出的代币符号（大写）
   - 常见代币映射：
     * "U"、"U币"、"USDc"、"USDC" → "USDC"
     * "ETH"、"以太坊" → "ETH"
     * "SOL"、"Solana" → "SOL"
     * "MATIC" → "MATIC"
     * "USDT" → "USDT"
     * "DAI" → "DAI"
   
3. tokenOut: 要买入的代币符号（大写）
   - 同上映射规则
   
4. amount: 兑换数量（字符串格式）
   - 提取数字，保留小数点
   - 如："10", "50.5", "1000"

## 解析规则：
1. 识别网络关键词：
   - "Base上"、"Base链" → "base"
   - "Polygon"、"Matic网络" → "polygon"
   - "以太坊"、"ETH链" → "ethereum"
   - "Solana"、"SOL链" → "solana"
   
2. 识别代币关键词：
   - "换成"、"兑换成"、"换取" 后面的代币是 tokenOut
   - "用"、"把"、"将" 后面的代币是 tokenIn
   
3. 数量提取：
   - 提取所有数字，取第一个完整数量

## 示例：
输入："帮我在Base上用10USDC换成ETH"
输出：{"chain": "base", "tokenIn": "USDC", "tokenOut": "ETH", "amount": "10"}

输入："把我50U兑换成Polygon上的MATIC"
输出：{"chain": "polygon", "tokenIn": "USDC", "tokenOut": "MATIC", "amount": "50"}

输入："在以太坊兑换100USDT为DAI"
输出：{"chain": "ethereum", "tokenIn": "USDT", "tokenOut": "DAI", "amount": "100"}

输入："把Solana上的50个SOL换成Ethereum中的ETH"
输出：{"chain": "ethereum", "tokenIn": "SOL", "tokenOut": "ETH", "amount": "50"}

输入："兑换20个ETH"
输出：{"chain": "ethereum", "tokenIn": "ETH", "tokenOut": "", "amount": "20"}

## 重要：
- 只输出JSON，不要有其他文字
- JSON必须完整，即使某些字段为空
- 确保JSON格式正确"""
    
    def _extract_json_from_response(self, response) -> Dict:
        """
        从大模型响应中提取并解析JSON
        支持多种响应格式
        """
        # 检查响应是否为None
        if response is None:
            return self._fallback_parse("")
            
        # 获取响应内容
        if isinstance(response, list):
            if not response:  # 检查列表是否为空
                return self._fallback_parse("")
            content = response[-1].content if hasattr(response[-1], 'content') else str(response[-1])
        else:
            content = str(response)
        
        # 清理内容，提取JSON部分
        json_str = self._clean_and_extract_json(content)
        
        # 解析JSON
        try:
            result = json.loads(json_str)
            
            # 验证必需字段
            required_fields = ["chain", "tokenIn", "tokenOut", "amount"]
            for field in required_fields:
                if field not in result:
                    result[field] = ""
            
            # 标准化处理
            result = self._normalize_result(result)
            return result
            
        except json.JSONDecodeError as e:
            print(f"JSON解析失败: {e}")
            print(f"原始内容: {content[:200]}")
            return self._fallback_parse(content)
    
    def _clean_and_extract_json(self, text: str) -> str:
        """
        清理文本，提取JSON部分
        处理大模型可能返回的多种格式
        """
        # 检查text是否为None或空字符串
        if not text:
            return "{}"
        
        # 尝试找到JSON对象
        json_patterns = [
            r'\{[^{}]*\}',  # 简单JSON
            r'```json\n(.*?)\n```',  # 代码块中的JSON
            r'```\n(.*?)\n```',  # 代码块
        ]
        
        for pattern in json_patterns:
            matches = re.findall(pattern, text, re.DOTALL)
            if matches:
                return matches[0].strip()
        
        # 如果没有找到，尝试提取括号内的内容
        brace_match = re.search(r'\{.*\}', text, re.DOTALL)
        if brace_match:
            return brace_match.group()
        
        # 如果还是找不到，返回原始文本（让JSON解析失败进入fallback）
        return text.strip()
    
    def _normalize_result(self, result: Dict) -> Dict:
        """
        标准化解析结果
        确保字段格式一致
        """
        # 链名称标准化（转小写）
        if "chain" in result:
            chain = str(result["chain"]).strip().lower()
            
            # 常见链映射
            chain_mapping = {
                "base chain": "base",
                "base": "base",
                "polygon": "polygon",
                "matic": "polygon",
                "polygon network": "polygon",
                "ethereum": "ethereum",
                "eth": "ethereum",
                "以太坊": "ethereum",
                "arbitrum": "arbitrum",
                "optimism": "optimism",
                "avalanche": "avalanche",
                "bsc": "bsc",
                "币安智能链": "bsc",
                "solana": "solana",
                "sol": "solana"
            }
            result["chain"] = chain_mapping.get(chain, chain)
        
        # 代币标准化（转大写）
        token_mapping = {
            "u": "USDC",
            "usdc": "USDC",
            "usd coin": "USDC",
            "usdt": "USDT",
            "tether": "USDT",
            "eth": "ETH",
            "ethereum": "ETH",
            "sol": "SOL",
            "solana": "SOL",
            "matic": "MATIC",
            "polygon": "MATIC",
            "dai": "DAI",
            "weth": "WETH",
            "wbtc": "WBTC",
            "btc": "BTC",
            "bitcoin": "BTC"
        }
        
        for field in ["tokenIn", "tokenOut"]:
            if field in result:
                token = str(result[field]).strip().upper()
                # 如果token是空，保持原样
                if token:
                    result[field] = token_mapping.get(token.lower(), token)
        
        # 数量标准化（确保是字符串）
        if "amount" in result:
            amount = str(result["amount"]).strip()
            # 移除非数字字符（除了小数点和逗号）
            amount_clean = re.sub(r'[^\d.,]', '', amount)
            if amount_clean:
                result["amount"] = amount_clean
            else:
                # 尝试从文本中提取数字
                num_match = re.search(r'(\d+(?:\.\d+)?)', amount)
                result["amount"] = num_match.group(1) if num_match else "0"
        
        return result
    
    def _fallback_parse(self, text: str) -> Dict:
        """
        大模型解析失败时的降级方案
        使用简单的启发式规则
        """
        # 仅在大模型完全失败时使用
        return {
            "chain": "ethereum",
            "tokenIn": "",
            "tokenOut": "",
            "amount": "0"
        }
```

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-03-1764775128571-img.png)
<!-- DAILY_CHECKIN_2025-12-03_END -->

# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->





运行一个基于 qwen-agent 的聊天应用试试  
  
创建项目，页面使用 qwen-agent 自带的 WebUI

![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667007234-img_1.png)

配置项，主要是api\_key 和自定义工具（my\_image\_gen，i\_upper）

![img_2.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667106692-img_2.png)

运行结果

![img_3.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667074362-img_3.png)

i\_upper 工具

![img_4.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-02-1764667082545-img_4.png)
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->






使用qwen-plus模型  
  
添加联网搜索模式，增加数据的真实性

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-01-1764569084856-img.png)

![img_1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-12-01-1764569097141-img_1.png)
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-30
<!-- DAILY_CHECKIN_2025-11-30_START -->







一个账户管理所有链上资产  
  
1\. 目标用户：多链DeFi农民，资产分散在5-8条不同链上，厌倦了反复跨链、切换网络、管理无数钱包的资深用户。  
  
2\. 解决的核心痛点：资产碎片化；操作复杂且风险高；收益机会流失，由于操作复杂，用户很难实时将资金调配到当下收益率最高的协议中，错过许多瞬时的优质机会。  
  
3\. 使用方式：用户看到Base链有个新协议收益率很高，检查各链余额，选择资金最多的链跨链到Base，等待确认，在新协议存款授权，完成投资。提取收益时，选择最优位置的资产 → 跨链聚合 → 法币出金。  

![img.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-30-1764502576986-img.png)
<!-- DAILY_CHECKIN_2025-11-30_END -->

# 2025-11-29
<!-- DAILY_CHECKIN_2025-11-29_START -->








合约一旦部署之后，是不可篡改的，那么前期MVP版本的合约功能并不完善，如果需要升级，应该如何实现呢？这就需要用到代理合约，代理模式有以下几种：  
  
1\. 代理模式：使用代理合约将调用委托给实际的功能合约（逻辑合约）。用户与代理合约交互，而代理合约将调用转发给逻辑合约。当需要升级时，可以将代理合约指向新的逻辑合约。  
2\. 钻石模式：也称为EIP-2535，允许合约具有多个逻辑合约，每个逻辑合约负责不同的功能（称为facet）。通过一个钻石合约来管理这些facet，可以添加、替换或删除功能。  
3\. 版本化合约：部署多个版本的合约，并让用户与最新版本的合约交互。但是，这种方式需要迁移状态，可能比较复杂。  
4\. 模块化合约：将功能拆分为多个模块，每个模块是一个独立的合约。通过主合约来调用这些模块，升级时只需替换或添加模块。  
  
代理模式中分为：  
1\. 透明代理：通过代理合约的fallback函数将调用委托给逻辑合约。同时，代理合约本身也有一些管理函数（如升级函数），只有管理员可以调用。为了避免管理员和普通用户的调用冲突，透明代理规定：管理员调用管理函数，而普通用户调用逻辑合约的函数。  
2\. UUPS（Universal Upgradeable Proxy Standard）：  
UUPS是另一种代理模式，它将升级逻辑放在逻辑合约中，而不是代理合约中。这样代理合约更简单，但要求逻辑合约必须实现升级功能。  
  
一般情况应该使用 UUPS 代理，参考 GatewayEVM 等基本用的都是这种，它使用到 @openzeppelin/contracts-upgradeable，继承 Initializable, UUPSUpgradeable  
  
具体逻辑如图：

![proxy.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-29-1764420326309-proxy.png)
<!-- DAILY_CHECKIN_2025-11-29_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->









## ERC20 和 ZRC20

ERC20 不具备跨链，需要桥接和其他协议。ZRC20 为外链资产在 ZetaChain 上的表示，能与Gateway 协同执行跨链提现、消息调用  
  
ERC20 即源码中的 asset 为外链合约地址，ZRC20 地址可由函数 getAllZRC20Tokens 获取，官方文档也有地址列表  
[https://www.zetachain.com/docs/developers/evm/zrc20/](https://www.zetachain.com/docs/developers/evm/zrc20/)

## 通用资产应用场景

一款跨链游戏  
  
游戏道具（NFT）可以在任意链铸造、交易、使用，并能无缝转移到另一条链继续用。  
  
游戏代币（ERC-20）可以在任意链支付手续费、参与治理、在跨链副本中结算奖励。

## 研究一下 Gas 消耗，为什么实践与理论不符合？

对比 memory 和 calldata 的 gas 消耗  
  

![gas_code.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-28-1764330335938-gas_code.png)

  
  
以下是消耗结果：  
  
User{uint8 age; unit256 balance}

|   | calldata | memory |
| --- | --- | --- |
| deploy | 310833 | 280877 |
| addUser | 67199 | 66650 |

User{uint256 age; unit256 balance}  

|   | calldata | memory |
| --- | --- | --- |
| deploy | 267168 | 256684 |
| addUser | 67181 | 66584 |

为什么 calldata 的消耗比 memory 多呢？貌似和理论不符？  
  
首先相比 User 结构体，age 由 unit8 变为 uint256，消耗都降低了，这是为什么？  
  
这得请出我们的大模型来拷打一番，模型是这样解释的：  
\`\`\`text  
calldata 操作：  
\- calldataload 读取 age (32字节，含31字节填充)  
\- calldataload 读取 balance (32字节)  
\- 掩码操作提取 uint8  
\- 存储操作  
  
memory 操作：  
\- mload 读取打包数据 (可能更高效)  
\- 直接存储  
\`\`\`  
1\. 混合类型结构体的部署差异更大  
2\. 相同类型结构体差异较小  
3\. 说明编译器对 memory 版本生成更优化的字节码  
  
1\. calldata 版本强制函数为 external 语义  
2\. memory 版本允许函数作为 public 函数，可能被内部调用  
3\. 外部调用有额外的 ABI 解码开销  
  
然后看下同一结构体下，memory 为什么比 calldata 节省 gas？  
  
// 当调用 addUser 时：  
// calldata 路径：  
// 1. 从 calldata 读取结构体字段  
// 2. 解码 ABI 编码（包含填充）  
// 3. 存储到 mapping  
  
// memory 路径：  
// 1. 参数已经以优化格式存在于内存中  
// 2. 直接存储到 mapping（无需额外解码）  
  
编译器优化：memory 参数允许更多编译器优化  
  
调用语义：public 函数比 external 函数在某些场景更高效  
  
内存访问模式：EVM 对内存访问有更好的优化  
  
ABI 解码开销：calldata 需要严格的 ABI 解码  
  
好吧，虽然不知道它是不是在诓我，但侧面印证了**开发以理论为主，但实际测试比理论规则更重要**！
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->










昨日简单分析了 GatewayEVM 的源码实现，知道了托管合约与 zetaConnector 的作用，  
今日继续分析一下 GatewayZEVM 的源码实现。

首先这个肯定是部署在 ZetaChain 上的核心网关合约，那么它管理的一定是 ZRC20 代币和 ZETA 代币了。  
  
先来研究下 ZRC20 代币的管理部分  
  
GatewayZEVM 的代码，上半部分为 GatewayZEVM.sol 代码，下半部分为 ZRC20.sol 的代码

![deposit.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-27-1764223268436-deposit.png)

  
这个方法应该是外部链上的资产通过跨链桥转移到 ZetaChain，由协议地址调用（这是一个常量地址），zrc20 直接铸造相应数量的代币。  
  
这里我们结合 GatewayEVM 和 GatewayZEVM 两个合约，串起来分析一下 ETH 向 ZetaChian 跨链转移 USDC 的步骤：

![ge_deposit.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-27-1764223286739-ge_deposit.png)

1\. GatewayEVM 将 USDC 从 asset 转移到托管合约，通过 \_transferFromToAssetHandler 函数；  
2\. GatewayEVM 发出 Deposited 事件，其中包含原始的 asset 地址信息；  
3\. ZetaChain 协议监听 GatewayEVM 发出的 Deposited 事件，解析事件数据，获取存款信息（发送者、接收者、金额、资产地址等）  
4\. ZetaChain 协议调用 deposit 方法铸造 USDC:ETH 代币（图一中的方法）  
  
继续研究提现流程，从 ETH 中将 USDC 兑换为 BTC 链中的 BTC：  
  
以太坊侧  
1\. 应该是调用此方法：GatewayEVM.depositAndCall( receiver = UniversalAppOnZeta, amount = usdcAmount, asset = USDC\_ETH\_ADDRESS,  
message = abi.encode(targetZRC20BTC, btcRecipientBytes, true), revertOptions)  
  
ZetaChain 侧（Universal App 合约执行 onCall，从下载的官方 demo hello 中可以看到 onCall 方法）  
1\. onCall(context, zrc20In=USDC.ETH, amountIn, message)  
2\. 解析 message → (targetToken=ZRC20\_BTC, recipient=btcAddrBytes, withdrawFlag=true)  
3\. 估算跨链提现到 Bitcoin 的 gas/执行费： fee = IZRC20(targetToken).withdrawGasFee(recipient) 或 Gateway 提供的费用查询  
4\. 用部分 USDC.ETH 通过 DEX 兑换成 ZRC-20 BTC 的“目的链 gas 代币”所需数量，将剩余的 USDC.ETH 全部换成目标代币 ZRC-20 BTC  
5\. 提现到比特币链：调用 GatewayZEVM.withdraw(receiver, amount, zrc20, revertOptions)，发出事件提交给 ZetaChain 验证器（后续研究）  
  
可以看出跨链操作的主要逻辑还是集中在 GatewayEVM 和 GatewayZEVM 中的，那么Universal App 就是围绕 Gateway 提供的入口/出口方法编排自己的业务逻辑。
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->











# Universal App

部署在 ZetaChain 通用 EVM 上的智能合约，原生连接以太坊、比特币、Solana、BNB Chain 等多条区块链。  
  
既能接收来自任意已连接链的合约调用、消息和代币转账，也能主动向这些链发起合约调用和代币转账，可编排跨链的复杂多步骤交易。  
  
gas 抽象，在 ZetaChain 上均对应为 ZRC-20 代币，用户无需持有目标链气体代币，应用会自动通过兑换 ZRC-20 gas 代币来覆盖手续费。

# Gateway

ZetaChain 生态中连接各区块链与链上 Universal App 的统一交互入口。  
  
不同类型的链对应不同的 Gateway。双向交易支持，处理外部链到 ZetaChain 的入向交易的 Gateway 和处理 ZetaChain 到外部链的出向交易。  
  
下面我们研究下 EVM 链兼容的 Gateway 源码。

## GatewayEVM

部署在 EVM 链上的网关，与 Custody（托管合约）和 zetaConnector（Zeta 连接器）配合管理资产  
  
那么 Custody（托管合约）和 zetaConnector（Zeta 连接器）的作用和区别是什么？  
  
从 \_transferToAssetHandler 函数可以看到，当向 ERC20 代币地址转移资产时，如果代币地址是 Zeta 原生代币，那么它用的是连接器，否则用托管合约。 也就是说，托管合约和连接器处理的 token 不同。 细看方法，托管合约还有白名单机制，而且是向托管合约直接转移资产

![_transferToAssetHandler.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159330741-_transferToAssetHandler.png)

接下来我们看 \_transferFromToAssetHandler 函数，这个函数暂时不支持 ZETA 原生代币的转移，但是 ERC20 代币仍然是由托管合约来管理的。

![_transferFromToAssetHandler.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159350735-_transferFromToAssetHandler.png)

只是多了一个发送者参数，为什么就不支持 ZETA 代币的转移了呢？我们继续看下这两个函数调用的地方，可以发现，  
\_transferToAssetHandler 函数被 deposit 和 depositAndCall 这两个函数调用，其含义是向以太坊代币合约地址存入资金，  
而 \_transferFromToAssetHandler 函数被 executeWithERC20 函数调用，它执行了剩余代币（如果有）的回收操作。  
根据官方文档的说明，也证实了这一说法。

![executeWithERC20.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159366805-executeWithERC20.png)![gateway.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-26-1764159378183-gateway.png)
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->












# ZetaChain

## ZetaChain CLI 使用

### 参考官方文档创建一个 Universal Contract

```
# 创建 hello 项目
npx zetachain@latest new --project hello

yarn
forge soldeer update

forge build
```

```
# 启动环境
npx zetachain localnet start

# 查看第一个账户地址的私钥
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

# 用第一个账户的私钥部署 hello 项目中的 Universal 合约到本地环境然后获取地址，广播上链
UNIVERSAL=$(forge create Universal \
  --rpc-url http://localhost:8545 \
  --private-key $PRIVATE_KEY \
  --evm-version paris \
  --broadcast \
  --json | jq -r .deployedTo) && echo $UNIVERSAL
0x5bf5b11053e734690269C6B9D438F8C9d48F528A

# 获取 Ethereum 链的 Gateway 地址
GATEWAY_EVM=$(jq -r '.["11155112"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
0x09635F643e140090A9A8Dcd712eD6285858ceBef
```

### 测试

![call.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059008804-call.png)

分析控制台打印

![callPrint.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059092077-callPrint.png)

| 对象 | 地址 |  
|---------|--------------------------------------------|  
| 账户 | 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 |  
| Gateway | 0x09635F643e140090A9A8Dcd712eD6285858ceBef |  
| 通用合约 | 0x5bf5b11053e734690269C6B9D438F8C9d48F528A |

  
入站和出站交易的体现，命令输入后确认交易的 transaction hash 为账户向 Gateway 合约的交易，  
控制台打印的 transactionHash 为 Gateway 合约向链内通用合约的交易  
  
当连接链为EVM兼容链的时候，sender 的值会填充给 senderEVM

## 测试网 RPC、Faucet、Explorer

### RPC

EVM RPC：适合开发调试，无需API Key，适合本地CLI/脚本调用，https://zetachain-athens-evm.blockpi.network/v1/rpc/public  
  
Alchemy等其他第三方RPC：适合高流量场景，需要API Key，稳定性高

### Faucet

通过水龙头获得了测试网 token

![test_token.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059233038-test_token.png)

### Explorer

[https://testnet.zetascan.com/](https://testnet.zetascan.com/)

# Qwen API 调用

## 使用官方平台提供的大模型

申请 API key

## 本地部署大模型

本地部署的好处：定制化和可控性极强。支持对模型进行微调、量化压缩等优化，可接入私有知识库，深度集成到内网 OA 等系统；还能自由调整模型温度、top - p 等参数，适配特定业务场景。  
  
这里我选择 ollama 本地部署 qwen3:8b 大模型，新版 ollama 提供了聊天界面，选择模型会自动帮你安装。以下展示命令操作。  
  
ollama 官网下载地址：https://ollama.com/  
  
ollama 可部署模型列表：https://ollama.com/search  
  
每个模型都支持可训练参数的大小选择，参数越多，模型的学习能力和表达能力更强，但对硬件资源（显存、算力等）的需求也越高。  
  
以我 windows 台式机为例，2060显卡目前部署的是 qwen3:8b，资源刚好够用

![models.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059309611-models.png)

### 下载模型

```
# 下载大模型
ollama pull qwen3:8b
# ollama 会自动下载模型并启动服务（可不 pull 直接 run）
ollama run qwen3:8b
# 查看所有下载的大模型
ollama list
# 查看正在运行的大模型
ollama ps
# 停止运行
ollama stop qwen3:8b
```

![ollama_run.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059360200-ollama_run.png)

### 调用模型API

**需要开启 ollama 访问权限，ollama 端口为 11434**

![expose_ollama.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059430590-expose_ollama.png)

安装 SDK：yarn add openai

编写代码调用 API

![apiCode.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059522879-apiCode.png)![aiResponse.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-25-1764059546095-aiResponse.png)
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->













# ZetaChain

## 概括和优势

**通用区块链**

-   能够跨区块链生态实现原生连接，同时为非智能合约链带来可编程性；
    
-   包含通用权益证明、通用以太坊虚拟机、通用智能合约；
    
-   旨在降低普通人进入去中心化世界的门槛
    

**对于开发者**

-   链式编排功能，可通过单一智能合约协调多链复杂操作，简化开发过程的同时提供扩展性；
    
-   与以太坊 EVM 完全兼容的 UEVM，降低学习门槛，向前兼容性使应用无需修改代码或重新部署，简化运维；
    
-   无 gas 费的执行环境可以降低开发与部署的成本。
    

**对于普通用户**

-   实现无缝跨链资产交互，操作流程更简洁；
    
-   无 Gas 费执行环境和统一流动性池与验证者托管机制，降低了跨链交易中的双重支付、交易失败等风险；
    
-   随着整合更多新区块链，用于无需切换应用即可享受到一致、便捷的服务。
    

**环境安装**

| 环境 | 版本 |
| --- | --- |
| node -v | v24.11.0 |
| yarn -v | 1.22.22 |
| git -v | git version 2.50.1 |
| jq -V | jq-1.8.1 |
| forge -V | forge 1.4.4-stable |

### 安装 zetachain

```
npm install -g zetachain
zetachain -V
7.4.0 # 版本
```

### 打印所有连接在 ZetaChain 上的链

```
zetachain query chains list
```

![zetachain query chains list.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974134372-zetachain_query_chains_list.png)

Count 指来自该连接链的交易需要经过的确认次数，到达次数后交易才会被 ZetaChain 监测到

为了避免原生链出现**区块重组**或**双重支付**导致的交易失效

### 启动一个本地开发环境

```
npx zetachain localnet start
```

![npx zetachain localnet start.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974200876-npx_zetachain_localnet_start.png)

### Developers 页面  
[https://www.zetachain.com/docs/developers](https://www.zetachain.com/docs/developers)

![developers.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974219512-developers.png)

# Qwen

账号注册

![alibabacloud.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qky190525/images/2025-11-24-1763974232744-alibabacloud.png)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
