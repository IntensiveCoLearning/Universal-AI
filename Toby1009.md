---
timezone: UTC+8
---

# 長在土裡的馬鈴薯

**GitHub ID:** Toby1009

**Telegram:** @Yunizero

## Self-introduction

Bermu DAO Board Member | 
TBA Research Teach Team Leader |
NTU & NTUST Blockchain Club Member |
NTUST CSIE |
Cathay Blockhain RD Intern |
Sui Network Builder

## Notes

<!-- Content_START -->
# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->
## `Error問題解決 zetachain localnet start --chains sui`

關於使用`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，找到問題為什麼zetachain的sui localnet弄不起來了

從錯誤訊息中看到是沒有issue\_message\_context這個function，有看到是從/usr/local/share/localnet這邊呼叫的

查看後看到有protocol-contracts-sui/，裡面是放move合約的，然後裡面沒有issue\_message\_context這個function

從toml可以發現確實就是呼叫這合約

接著我去查zetachain localness src chains的sui，發現裡面有下載和呼叫protocol-contracts-sui/ 從repo中，然後我從上面clone下來後發現咋clone下來的有issue\_message\_context，執行後確實成功跑起來sui localnet了

這時我就好奇咋之前自動下載的會出問題，一看發現：

<[https://github.com/zeta-chain/protocol-contracts-sui](https://github.com/zeta-chain/protocol-contracts-sui)\> 他的main沒有issue\_message\_context，只有develop有，develop也是default，但自動抓會抓到main

總結就是：CLI指令會自動從repo抓和呼叫main branch的檔案，但是正確是要從develop抓才不會報錯，蠻神奇的

## Qwen

要先註冊阿里巴巴雲端，然後綁信用卡那些，我用u卡，他會轉1u出去再轉回來確定是否是正確的。

在 [Qwen API](https://modelstudio.console.alibabacloud.com/?tab=api#/api) 有介紹咋獲取API，首先我是在新加坡的playground弄的api，像這樣

![Screenshot 2025-11-25 at 9.33.32 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034421121-Screenshot_2025-11-25_at_9.33.32_AM.png)

[API參考](https://modelstudio.console.alibabacloud.com/?tab=api#/api/?type=model&url=2712576)中有python配置參考那些，根據配置先將剛剛的API key弄到環境變數DASHSCOPE\_API\_KEY，避免直接明文上去

然後URL就貼新加坡的。

![Screenshot 2025-11-25 at 9.34.15 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034509335-Screenshot_2025-11-25_at_9.34.15_AM.png)

成功後顯示：

![Screenshot 2025-11-25 at 9.36.13 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034585498-Screenshot_2025-11-25_at_9.36.13_AM.png)

這樣就代表能用api了

## ZetaChain架構理解

### 基礎

ZetaChain基於Consmos SDK和Comet BFT的POS，這昨天有寫，主要特性是出塊快！以及確定快！

也就是交易到打包都快，然後不太會有MEV以及區塊重組之類的問題（類似於Sui就不太會有MEV）

並且可擴展至約300個節點，以我的理解來說還行，像是Sui就只有100個節點@@ 但好奇ZetaChain質押要多少？

然後可以透過BLS門檻簽名技術升級，讓更多節點加入，TPS可達100左右。好奇門檻技術咋升級的？會不會有衝突？

### 組成

ZetaChain組成：

-   ZetaCore：
    
    -   負責生成區塊鏈
        
    -   負責維護狀態機，也就是區塊鏈本身的帳本與邏輯運作
        
-   ZetaClient：
    
    -   負責觀察連接鏈（如Ethereum,Bitcoin,Solana等)上的事件
        
    -   負責簽署發送到這些連接鏈的外部交易
        

這兩個組成一個驗證者節點，由節點運營商搞，只要有足夠的資產質押就能成為節點運營商

總而言之可以發現有理個角色，有點像是Ethereum的驗證者有多個角色一樣，但是每個驗證者不一定都會一直全部角色都會處理到，像是有出塊倡議者、證明者，以及同步委員會，這三個組成驗證者，而只有證明者比較常會是運作的，這也是基礎獎勵來源，其他兩個偶爾有，但獎勵不錯。

再來細講一下這兩個角色具體在幹麻：

-   核心驗證者（Core Validators）：
    
    -   職責：參與區塊生成和共識過程
        
    -   機制：使用Comet BFT 共識協議。驗證者對區塊提案進行投票，投票權重與質押或被委託的代幣（ZETA）數量成正比
        
    -   要求：需要時刻保持在線，以參與不斷增長的區塊生產
        
-   觀察者-簽署者驗證者（Observer-Signer Validators）：
    
    -   觀察者：
        
        -   透過運行連接鏈的全節點，監控外部鏈(如Bitcoin或Ethereum）上特定地址的相關交易、事件或狀態
            
    -   簽署者：
        
        -   擁有一部分密鑰分片。ZetaChain集體持有一組標準的ECDSA/EdDSA密鑰（因為這要看不同鏈的密鑰，像是Bitcoin/Ethereum就是ECDSA，而Solana/Sui就是EdDSA），用於與外部鏈進行驗證交互
            
        -   去中心化簽名：密鑰分再多個簽署者手中，只有當絕對多數的節點共同簽名時，才能代表ZetaChain在外部鏈上執行操作（例如轉移比特幣）
            
        -   安全性：沒有任何單一實體或少數節點可以單獨代表ZetaChain簽署訊息，確保了資產的安全性和去中心化
            

簡單來說就是，透過觀察者去監控其他鏈，然後將這些訊息傳到ZetaChain上面，會這樣做的原因是鏈上不會自動更新狀態，要透過外部去push才行，而觀察者就是負責觀察，然後傳到ZetaChain上面改變ZetaChain上面的狀態，也就是輸入，類似於預言機(Oracle）

而簽署者是輸出，將ZetaChain的訊息傳入到外部鏈，像是當ZetaChain上的智能合約決定要在外部鏈執行操作時（例如用戶想把資產提領回Ethereum，或是在外部鏈上調用合約），簽署者會利用門檻簽名（TSS）共同生成一個簽名去簽，而這個簽名會被廣播到外部鏈上，完成資產轉移或合約執行。

之所以要使用門檻簽名，是因為至少要多個節點承認此操作並進行操作才行，不然只有一個節點就能轉移資產實在有點危險xd

因為這兩個角色核心驗證者和觀察者-簽署者驗證者都是同個驗證者，所以會好奇所需硬體資源，以及質押量會不會很大？

硬體資源，不只是要跑ZetaChain節點，還要外部鏈全節點

而質押則是確保網路安全，不確定這部分要多少？

也很好奇ZetaChain當初怎麼解決冷啟動問題的？以及有沒有LST？
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->






## ZetaChain

ZetaChain的POS是基於Cosmos SDK和Comet BFT，可以在各個EVM鏈、Solana、Sui和TON，甚至是比特幣之間進行跨鏈調用

-   向前遷移讓在新區塊鏈加入時通用應用程式無需任何額外工作或修改合約原始碼。
    
-   原生代幣在所有連接的鏈上轉移，用戶可以進行涉及各區塊鏈實際原生資產的交易，而不是使用封裝或合成版本
    
-   開發環境與EVM相容，可以使用熟悉的工具
    
-   通用應用從已連接鏈被呼叫時，僅需在該已連接鏈上支付 Gas 費用，這種gasless的方式，解決了每次合約呼叫都需要在交易雙方支付 gas 費用的問題
    

### 安裝ZetaChain CLI

要先確保有：

-   Node.js`node --version` 檢查
    
-   Yarn`yarn --version` 檢查
    
-   Git`git --version` 檢查
    
-   jq`jq --version` 檢查
    
-   Foundry： `foundryup --version` & `forge --version` 檢查
    

安裝ZetaChain CLI：

```
npm install -g zetachain
```

> ZetaChain CLI是ZetaChain的主要工具，用於進行跨鏈調用、轉移代幣、追蹤跨鏈交易、管理跨多個網路的帳戶、查詢餘額等。

接著運行：

```
zetachain query chains list
```

> 此命令會列出目前連接到ZetaChain的所有鏈，可以確認設定是否正常

會出現下面這張圖：

![Screenshot 2025-11-23 at 4.06.26 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928567712-Screenshot_2025-11-23_at_4.06.26_AM.png)

本地開發最好用Localnet，是一個包含ZetaChain、EVM、Solana、Sui和TON的獨立環境，很方便建立和測試通用應用程式，是最快的方法。

執行Localnet要確保安裝Foundry，如果想運行包含非EVM鏈，可以查看\[Localnet文件\]([https://www.zetachain.com/docs/reference/localnet/](https://www.zetachain.com/docs/reference/localnet/))

在Localnet文件中提到Localnet是ZetaChain的一體化本機開發環境，用於建置、測試和調試通用應用程式，為多個鏈創建節點，並預先部署核心ZetaChain協議合約、ZRC-20代幣，以及Uniswap V2和V3池

使`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，改`yarn zetachain localnet start --chains sui`遇到同樣問題

![Screenshot 2025-11-23 at 8.47.52 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928675064-Screenshot_2025-11-23_at_8.47.52_AM.png)

有點好奇Sui的localnet是怎麽做到的？因為看ㄇSui上很少有可以模擬的localnet。

使`npx zetachain@latest localnet start`列印了Ethereum/ZetaChain/BNB的訊息，不過就卡住了，不確定是結束還是？

後來看文檔，不是卡住，是在監聽，所以是正常的不能關掉！

### 嘗試Hello

參考：\[First Universal Contract\]([https://www.zetachain.com/docs/developers/tutorials/hello](https://www.zetachain.com/docs/developers/tutorials/hello))

```
// SPDX-License-Identifier: MIT

pragma solidity 0.8.26;

import “@zetachain/protocol-contracts/contracts/zevm/interfaces/UniversalContract.sol”;

contract Universal is UniversalContract {

event HelloEvent(string, string);

function onCall(

MessageContext calldata context,

address zrc20,

uint256 amount,

bytes calldata message

) external override onlyGateway {

string memory name = abi.decode(message, (string));

emit HelloEvent("Hello: ", name);

}

}
```

> `onCall`只能`gateway`調用，以確保它僅作為對已連接鏈上調用的響應而被調用，並且您可以信任函數參數的值。這是`onlyGateway` 修飾符強制執行的，該修飾符繼承`UniversalContract`

這個就簡單的hello範例，連接EVM和ZetaChain，靠gateway傳輸，從EVM鏈通過gateway傳到ZetaChain

發送訊息，可以看到需要gateway/receiver/private-key參數

```
PRIVATE_KEY=$(jq -r ‘.private_keys[0]’ ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

```
UNIVERSAL=$(forge create Universal \

--rpc-url http://localhost:8545 \

--private-key $PRIVATE_KEY \

--evm-version paris \

--broadcast \

--json | jq -r .deployedTo) && echo $UNIVERSAL
```

```
GATEWAY_EVM=$(jq -r ‘.[“11155112”].contracts[] | select(.contractType == “gateway”) | .address’ ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

```
npx zetachain evm call \

--rpc <http://localhost:8545> \

--gateway $GATEWAY_EVM \

--receiver $UNIVERSAL \

--private-key $PRIVATE_KEY \

--types string \

--values hello
```

照著上面的流程部署和發送訊息在localnet不太會有問題，發送訊息後在localnet會有：

```
[Ethereum] Processing Called event from 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 to 0x5bf5b11053e734690269C6B9D438F8C9d48F528A

[ZetaChain] Universal contract 0x5bf5b11053e734690269C6B9D438F8C9d48F528A executing onCall (context: {“chainID”:“11155112”,“sender”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”,“senderEVM”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”}), zrc20: 0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe, amount: 0, message: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000)

[ZetaChain] Event from onCall: {“_type”:“log”,“address”:“0x5bf5b11053e734690269C6B9D438F8C9d48F528A”,“blockHash”:“0x40af578e8921789d94d775e8733c80db3edfea934ae24fc4b372c9a6bad838f7”,“blockNumber”:139,“data”:“0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000748656c6c6f3a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000”,“index”:0,“removed”:false,“topics”:[“0x39f8c79736fed93bca390bb3d6ff7da07482edb61cd7dafcfba496821d6ab7a3”],“transactionHash”:“0x9ce7ce063be9718e2020252b6385bc1e6a5ecdbf264dbe5f60db4226b5974cdc”,“transactionIndex”:0}
```

如果說要在testnet上運作的話，就要有錢包，裡面也要有錢錢

需要注意得是`UNIVERSAL`的時候負責部署的地址要有ZETA代幣，才能部署

而在發送訊息時，發送訊息的地址也要有該鏈的代幣，才能支付訊息傳遞的費用

比如，我要從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，我要：

-   部`UNIVERSAL`合約在ZataChain Testnet，這時ZetaChain Testnet的錢包要有ZETA代幣才能部署
    
-   從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，這時Base Sepolia的錢包要有Base Sepolia的ETH才能支付訊息傳遞費用
    

將MetaMask連接到ZetaChain Testnet和Base Sepolia，並確保兩個錢包都有足夠的代幣，以下是我的解法：

-   MetaMask連接ZetaChain Testnet：\[revoke Add ZetaChain to MetaMask\]([https://revoke.cash/learn/wallets/add-network/zetachain](https://revoke.cash/learn/wallets/add-network/zetachain))
    
-   MetaMask連接到Base Sepolia：\[revoke Add Base Sepolia to MetaMask\]([https://revoke.cash/learn/wallets/add-network/base-sepolia](https://revoke.cash/learn/wallets/add-network/base-sepolia))
    
-   透過DC領取ZETA代幣`zeta faucet drip [address]`
    
-   透過\[Google Clound Web3 Ethereum Sepolia Faucet\]([https://cloud.google.com/application/web3/faucet/ethereum/sepolia)領取Ethereum](https://cloud.google.com/application/web3/faucet/ethereum/sepolia\)%E9%A0%98%E5%8F%96Ethereum) Sepolia ETH，再使用跨鏈橋轉到Base Sepolia
    

如果餘額不夠會顯示：

![Screenshot 2025-11-23 at 9.12.53 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928614412-Screenshot_2025-11-23_at_9.12.53_AM.png)

正確會是這樣：

![Screenshot 2025-11-23 at 9.13.01 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928628741-Screenshot_2025-11-23_at_9.13.01_AM.png)

可以在Base Sepolia的區塊鏈瀏覽器查看交易狀態：<[https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57](https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57)\>

可以`npx zetachain query cctx`追蹤跨鏈交易狀態

我`npx zetachain query cctx --hash 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57`：

```
84532 → 7001 ✅ OutboundMined

CCTX: 0xeb314c04807c86709db41d2794bb7a3b9eca77c230717e510035211b81b95fa6

Tx Hash: 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57 (on chain 84532)

Tx Hash: 0x418b305cc89831f24bac419068d8b535a23d836b445820e92655d028fae2bb4c (on chain 7001)

Sender: 0x1Ab8cA7b9f7505a89b4abbfB1B58337CAAF6f71a

Receiver: 0xA78EE9ADD2009d7a004a6c26AE0fe88c47824B01

Message: 0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000
```

-   84532 → 7001 ✅ OutboundMined：表示跨鏈交易已成功從鏈84532發送到鏈7001
    
-   CCTX: 是 ZetaChain 上的跨鏈交易 (CCTX) 的雜湊值，表示此特定跨鏈操作的內部識別碼
    
-   Tx Hash: 分別是來源與目標的tx hash
    
-   Sender: 是發送跨鏈交易的地址
    
-   Receiver: ZetaChain 上接收方合約的地址
    
-   Message: 是跨鏈交易中傳遞的訊息內容，剛剛發送的字串，經過 EVM ABI 編碼 (ABI Encoded) 後的樣子
    

## QWEN

-   在\[qwen聊天室\]([https://chat.qwen.ai/)與\[阿里巴巴Cloud\](https://account.alibabacloud.com/intl/supply\_userinfo/index#/basic/)建立帳號](https://chat.qwen.ai/\)%E8%88%87%5B%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Cloud%5D\(https://account.alibabacloud.com/intl/supply_userinfo/index#/basic/\)%E5%BB%BA%E7%AB%8B%E5%B8%B3%E8%99%9F)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
