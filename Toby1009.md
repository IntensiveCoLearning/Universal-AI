---
timezone: UTC+8
---

# 長在土裡的馬鈴薯

**GitHub ID:** Toby1009

**Telegram:** @Yunizero

## Self-introduction

Bermu DAO Board Member | 
TBA Research Teach Team Leader |
NTU & NTUST Blockchain Club Member |
NTUST CSIE |
Cathay Blockhain RD Intern |
Sui Network Builder

## Notes

<!-- Content_START -->
# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->
## Hello App 前端

這個專案是用之前Hello的

前端整題流程會是：

-   連結錢包：能夠用MetaMask，獲取使用者地址、簽署和發送交易
    

-   選擇網路：在UI上提供選單，讓使用者選擇「來源鏈」
    
-   輸入訊息：提供一個輸入框，讓使用者輸入想要跨鏈發送的字串（例如"Hello ZetaChain"）
    
-   發送跨鏈呼叫：
    
    -   這是核心的地方，前端會使用ZetaChain Toolkit 中的 `evmcCall` 函式
        
    -   參數設定：指定接收者（ZetaChain上的合約地址）、編碼後的訊息內容、Gas限制等。
        
    -   使用者在錢包中確認並簽署交易，將訊息發送到ZetaChain上的Universal合約
        
-   追蹤結果：
    
    -   前端會顯示來源鏈的交易Hash
        
    -   接著App會輪詢（Poll）ZetaChain的狀態，查詢跨鏈交易（CCTX）是否已完成
        
    -   最後顯示來源鏈和ZetaChain區塊鏈瀏覽器（Explorer）的連結，證明跨鏈訊息已成功處理。
        

首先，進到之前的Hello專案，然後安裝一下依賴

```
cd hello/frontend
yarn
```

如果沒有的話就重新建立：

```
npx zetachain@latest new --project hello
cd hello/frontend
yarn
```
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->

## 練習與Sui交互

輸入 \`npx zetachain localnet start --chains sui \`來啟動localnet

會出現下面這畫面，代表好了，也代表localnet正式啟動

![Screenshot 2025-11-26 at 3.24.52 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764098701393-Screenshot_2025-11-26_at_3.24.52_AM.png)

下面這張圖顯示有999.92得餘額，並且env在localnet

localnet在：[http://127.0.0.1:9000](http://127.0.0.1:9000)

這是可以在sui的explorer中輸入的，在explorer看交易比較方便

舉個例子，在suiscan中切換成[http://127.0.0.1:9000](http://127.0.0.1:9000) 可以看到資訊蠻清楚的，有成功顯示這畫面代表localnet搞好了

![Screenshot 2025-11-26 at 3.28.08 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764098915941-Screenshot_2025-11-26_at_3.28.08_AM.png)

接著我要練習call from sui 和call to sui ，徹底學習咋跟sui互動

call from sui：顧名思義就是從sui去呼叫

call to sui：就是呼叫sui

簡單易懂吧？那我先來看看Call from sui 要尬麻

一樣，先建立新專案

```
npx zetachain@latest new --project call
cd call
```

接著安裝依賴

```
yarn
forge soldeer update
```

然後剛剛有開過了localnet，就不贅述了

首先要先把universal smart contract 部署到ZetaChain，合約的部分上次hello的時候說過了

```
GATEWAY_ZETACHAIN=$(jq -r '.["31337"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_ZETACHAIN
```

從上面可以看到從31337的gateway那邊拿到拿到gateway的address，名字也叫GATEWAY\_ZETACHAIN，上次的是GATEWAY\_EVM

那這差在哪？

![Screenshot 2025-11-26 at 4.09.42 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764101760622-Screenshot_2025-11-26_at_4.09.42_AM.png)![Screenshot 2025-11-26 at 4.15.49 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764101771391-Screenshot_2025-11-26_at_4.15.49_AM.png)

可以看到31337是ZetaChain的，而11155112是Ethereum的，從名字也可以看出來GATEWAY\_ZETACHAIN / GATEWAY\_EVM

接著去弄弄私鑰，因為要部署要私鑰

```
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

然後編譯編譯合約

```
forge build
```

沒啥問題就部署Universal合約

```
npx zetachain sui deposit \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x17360c15c10bbc4ebc57e9872f2993dc4376f7f0bb78920fe5fa9ad276ac7f86 \
  --gateway-object 0x9a26d6b6f413228bb120446977a8d8003eceb490cb7afd8921494815adc0a497 \
  --amount 0.001 \
  --chain-id 104
```

輸入這，但要注意！！！

> gateway-package和gateway-object要替換掉，替換成localnet輸出的值
> 
> 在當初zetachain localnet start --chains sui起localnet時就會在各個鏈中搞個gateway負責接收和傳遞訊息！現在填的gateway就是sui上的

下面這張圖就是當初zetachain localnet start --chains sui時部署上去的package的詳細資訊，從suiscan上看

![Screenshot 2025-11-26 at 4.40.34 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764103250752-Screenshot_2025-11-26_at_4.40.34_AM.png)

chain-id的104是啥呢，從前面localnet的輸出上看，就是代表Sui鏈

成功後會長下面這樣

![Screenshot 2025-11-26 at 4.34.05 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764102949675-Screenshot_2025-11-26_at_4.34.05_AM.png)

Transaction hash可以從explore來看

![Screenshot 2025-11-26 at 9.51.40 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764121917762-Screenshot_2025-11-26_at_9.51.40_AM.png)![Screenshot 2025-11-26 at 9.51.47 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764121932158-Screenshot_2025-11-26_at_9.51.47_AM.png)

可以看到是去gateway的deposit，從 [**gateway.move**](https://github.com/zeta-chain/protocol-contracts-sui/blob/develop/sources/gateway.move#L325) 中 可以看到

![Screenshot 2025-11-26 at 9.49.20 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122017596-Screenshot_2025-11-26_at_9.49.20_AM.png)![Screenshot 2025-11-26 at 9.49.07 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122030545-Screenshot_2025-11-26_at_9.49.07_AM.png)

他就將錢錢deposit到他們gateway的小金庫中！

再回到剛剛的地方

![Screenshot 2025-11-26 at 5.07.53 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122186654-Screenshot_2025-11-26_at_5.07.53_AM.png)

可以看到active-addressess跟sender不同，這時可能會覺得奇怪？咋不同？資金哪來的？

我也是查了又查，發現自己在耍笨，其實是mnemonic後面那串就會做：

-   透過助記詞創建密鑰對生成地址
    
-   去水龍頭領水(faucet)
    

所以就又有地址又有錢啦！但不知道錢錢的部分是不是限定localnet？晚點試試

![Screenshot 2025-11-26 at 5.22.58 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764110395149-Screenshot_2025-11-26_at_5.22.58_AM.png)

上圖是terminal上localnet持續監聽的結果，顯示交易細節，交易成功

寫 `0x777915D031d1e8144c90D025C594b3b8Bf07a08d`存了個token`0x927b167526bAbB9be047421db732C663a0b77B11`，這`0x777915D031d1e8144c90D025C594b3b8Bf07a08d`是誰勒？

![Screenshot 2025-11-26 at 6.05.19 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764111144477-Screenshot_2025-11-26_at_6.05.19_AM.png)

> 小知識：cast run \[tx hash\]可以查交易細節（Trace），可以先透過cast block latest查到最後一筆交易

上面可以看到有三層

從 [**GatewayZEVM.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/GatewayZEVM.sol) 中有這個呼叫的code

![Screenshot 2025-11-26 at 8.43.23 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764118995506-Screenshot_2025-11-26_at_8.43.23_AM.png)

前面先檢查了一些東東，比較重要的是最後

```
if (!IZRC20(zrc20).deposit(target, amount)) revert ZRC20DepositFailed();
```

這邊會呼叫下一層存款，在 [**IZRC20.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/interfaces/IZRC20.sol)中

![Screenshot 2025-11-26 at 9.11.58 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119530766-Screenshot_2025-11-26_at_9.11.58_AM.png)

而他的實作在 [**ZRC20.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/ZRC20.sol) 中

![Screenshot 2025-11-26 at 9.13.25 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119615704-Screenshot_2025-11-26_at_9.13.25_AM.png)![Screenshot 2025-11-26 at 9.14.39 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119696288-Screenshot_2025-11-26_at_9.14.39_AM.png)

在deposit中主要做了四件事：

1.  檢查發送者權限
    
2.  鑄幣 (Mint) -> 對應 Trace 的 Transfer 事件
    
3.  發出事件 -> 對應 Trace 的 Deposit 事件
    
4.  回傳 -> 對應 Trace 的 Return
    

以上就對上了Trace的三層結構，總結來說就是會mint代幣出來，然後把目標地址的餘額增加

> 這邊mint的是ZRC20，直接增發，然後在目標地址上的餘額增加
> 
> 但這讓我覺得EVM這種transfer只是在balance\[account\]做加減要有點信任協議誒，像是Sui的代幣是owner\_object，在transfer時就是將該代幣轉移給使用者（地址），只有該代幣使用者（地址）有權限，也就是其他地址無法去操控該代幣，連帶協議也是，也就是餘額不會被偷改。
> 
> 怕會有重入風險，跟群裡大佬討論後覺得主要是看協議合約是否有寫好，有寫好就沒問題，推CEI原則寫的話就比較安全，這我要去學學了！

這邊肯定又會好奇Trace中deposit 是從 `0x735b14bb79463307aacbed86daf3322b1e6226ab` 傳到目標地址的，那這是啥勒

從ZRC20合約中deposit function內有看到

```
 emit Deposit(abi.encodePacked(FUNGIBLE_MODULE_ADDRESS), to, amount);
```

其中的FUNGIBLE\_MODULE\_ADDRESS，是一個由協議維護的、固定的地址，總而言之就是協議地址

![Screenshot 2025-11-26 at 9.30.38 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764120756536-Screenshot_2025-11-26_at_9.30.38_AM.png)

也就是從協議中把代幣deposit到目標地址！

小結：從前面的過程中，可以發現，call from sui 的deposit主要就是，將sui 轉到sui上的gateway放進裡面的小金庫，然後zetachain上會由協議mint新代幣，並且轉到目標地址上，而這個目標地址是剛部署在zetachain上的Universal合約。其中sui上的gateway是在建立localnet時就部署上去了。

不過咋Universal存了錢沒反應？？？

其實可以換成呼叫deposit-and-call的方式，相比於deposit，他還會觸發Universal的onCall

```
npx zetachain sui deposit-and-call \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x17360c15c10bbc4ebc57e9872f2993dc4376f7f0bb78920fe5fa9ad276ac7f86 \
  --gateway-object 0x9a26d6b6f413228bb120446977a8d8003eceb490cb7afd8921494815adc0a497 \
  --amount 0.001 \
  --chain-id 104 \
  --types string \
  --values hello
```

> 同樣的gateway-package/gateway-object也要改

所以deposit整體流程再次總結：

-   **Sui 世界**：你 -> 調用 **Sui Gateway (Move)** -> 錢被鎖定在 Sui。 _(這裡是你 CLI 指令_ `zetachain sui deposit` _發生的地方)_ ↓ _(ZetaChain 的驗證節點觀察到這一幕)_ ↓
    
-   **ZetaChain 世界**：驗證節點（有效性投票，多數同意後更新CCTX） -> 調用 **ZEVM Gateway (Solidity)** -> 錢被 Mint 出來 -> 轉給 **Universal 合約** 。
    

> 追蹤 CCTX 需要使用入站交易雜湊值查詢 ZetaChain 的 Cosmos SDK HTTP API，以取得 CCTX 雜湊值。如果一個 CCTX 產生了另一個 CCTX（例如，入站交易產生了出站交易），則可以使用第一個 CCTX 哈希值作為入站哈希值來獲取第二個 CCTX 哈希值。

## Universal資產和Gateway圖解

我覺得[Universal Asset overview](https://www.zetachain.com/docs/developers/standards/overview)的圖畫的很好，很傳神哈哈：

![https://excalidraw.com/#json=dQJisu_uJ0N8T6IPi2m0E,PJU63ktFfbi1WsfAXsompA](https://www.zetachain.com/docs/_next/image/?url=%2Fdocs%2F_next%2Fstatic%2Fmedia%2Ftutorials-nft.1d7d1ca2.png&w=3840&q=75)

上面這張圖是以NFT為例

或是 [**qwe638853**](https://github.com/IntensiveCoLearning/Universal-AI/blob/main/qwe638853.md)的筆記的圖：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764097834061-image.png)

> 圖是用Excalidraw畫

其實就跟我前面提到的一樣
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->



















## `Error問題解決 zetachain localnet start --chains sui`

關於使用`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，找到問題為什麼zetachain的sui localnet弄不起來了

從錯誤訊息中看到是沒有issue\_message\_context這個function，有看到是從/usr/local/share/localnet這邊呼叫的

查看後看到有protocol-contracts-sui/，裡面是放move合約的，然後裡面沒有issue\_message\_context這個function

從toml可以發現確實就是呼叫這合約

接著我去查zetachain localness src chains的sui，發現裡面有下載和呼叫protocol-contracts-sui/ 從repo中，然後我從上面clone下來後發現咋clone下來的有issue\_message\_context，執行後確實成功跑起來sui localnet了

這時我就好奇咋之前自動下載的會出問題，一看發現：

<[https://github.com/zeta-chain/protocol-contracts-sui](https://github.com/zeta-chain/protocol-contracts-sui)\> 他的main沒有issue\_message\_context，只有develop有，develop也是default，但自動抓會抓到main

總結就是：CLI指令會自動從repo抓和呼叫main branch的檔案，但是正確是要從develop抓才不會報錯，蠻神奇的

## Qwen

要先註冊阿里巴巴雲端，然後綁信用卡那些，我用u卡，他會轉1u出去再轉回來確定是否是正確的。

在 [Qwen API](https://modelstudio.console.alibabacloud.com/?tab=api#/api) 有介紹咋獲取API，首先我是在新加坡的playground弄的api，像這樣

![Screenshot 2025-11-25 at 9.33.32 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034421121-Screenshot_2025-11-25_at_9.33.32_AM.png)

[API參考](https://modelstudio.console.alibabacloud.com/?tab=api#/api/?type=model&url=2712576)中有python配置參考那些，根據配置先將剛剛的API key弄到環境變數DASHSCOPE\_API\_KEY，避免直接明文上去

然後URL就貼新加坡的。

![Screenshot 2025-11-25 at 9.34.15 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034509335-Screenshot_2025-11-25_at_9.34.15_AM.png)

成功後顯示：

![Screenshot 2025-11-25 at 9.36.13 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034585498-Screenshot_2025-11-25_at_9.36.13_AM.png)

這樣就代表能用api了

## ZetaChain架構理解

### 基礎

ZetaChain基於Consmos SDK和Comet BFT的POS，這昨天有寫，主要特性是出塊快！以及確定快！

也就是交易到打包都快，然後不太會有MEV以及區塊重組之類的問題（類似於Sui就不太會有MEV）

並且可擴展至約300個節點，以我的理解來說還行，像是Sui就只有100個節點@@ 但好奇ZetaChain質押要多少？

然後可以透過BLS門檻簽名技術升級，讓更多節點加入，TPS可達100左右。好奇門檻技術咋升級的？會不會有衝突？

### 組成

ZetaChain組成：

-   ZetaCore：
    
    -   負責生成區塊鏈
        
    -   負責維護狀態機，也就是區塊鏈本身的帳本與邏輯運作
        
-   ZetaClient：
    
    -   負責觀察連接鏈（如Ethereum,Bitcoin,Solana等)上的事件
        
    -   負責簽署發送到這些連接鏈的外部交易
        

這兩個組成一個驗證者節點，由節點運營商搞，只要有足夠的資產質押就能成為節點運營商

總而言之可以發現有兩個角色，有點像是Ethereum的驗證者有多個角色一樣，但是每個驗證者不一定都會一直全部角色都會處理到，像是有出塊倡議者、證明者，以及同步委員會，這三個組成驗證者，而只有證明者比較常會是運作的，這也是基礎獎勵來源，其他兩個偶爾有，但獎勵不錯。

再來細講一下這兩個角色具體在幹麻：

-   核心驗證者（Core Validators）：
    
    -   職責：參與區塊生成和共識過程
        
    -   機制：使用Comet BFT 共識協議。驗證者對區塊提案進行投票，投票權重與質押或被委託的代幣（ZETA）數量成正比
        
    -   要求：需要時刻保持在線，以參與不斷增長的區塊生產
        
-   觀察者-簽署者驗證者（Observer-Signer Validators）：
    
    -   觀察者：
        
        -   透過運行連接鏈的全節點，監控外部鏈(如Bitcoin或Ethereum）上特定地址的相關交易、事件或狀態
            
    -   簽署者：
        
        -   擁有一部分密鑰分片。ZetaChain集體持有一組標準的ECDSA/EdDSA密鑰（因為這要看不同鏈的密鑰，像是Bitcoin/Ethereum就是ECDSA，而Solana/Sui就是EdDSA），用於與外部鏈進行驗證交互
            
        -   去中心化簽名：密鑰分再多個簽署者手中，只有當絕對多數的節點共同簽名時，才能代表ZetaChain在外部鏈上執行操作（例如轉移比特幣）
            
        -   安全性：沒有任何單一實體或少數節點可以單獨代表ZetaChain簽署訊息，確保了資產的安全性和去中心化
            

簡單來說就是，透過觀察者去監控其他鏈，然後將這些訊息傳到ZetaChain上面，會這樣做的原因是鏈上不會自動更新狀態，要透過外部去push才行，而觀察者就是負責觀察，然後傳到ZetaChain上面改變ZetaChain上面的狀態，也就是輸入，類似於預言機(Oracle）

而簽署者是輸出，將ZetaChain的訊息傳入到外部鏈，像是當ZetaChain上的智能合約決定要在外部鏈執行操作時（例如用戶想把資產提領回Ethereum，或是在外部鏈上調用合約），簽署者會利用門檻簽名（TSS）共同生成一個簽名去簽，而這個簽名會被廣播到外部鏈上，完成資產轉移或合約執行。

之所以要使用門檻簽名，是因為至少要多個節點承認此操作並進行操作才行，不然只有一個節點就能轉移資產實在有點危險xd

因為這兩個角色核心驗證者和觀察者-簽署者驗證者都是同個驗證者，所以會好奇所需硬體資源，以及質押量會不會很大？

硬體資源，不只是要跑ZetaChain節點，還要外部鏈全節點

而質押則是確保網路安全，不確定這部分要多少？

如果說這兩者所需要的門檻都很高，那加入驗證者的門檻自然就更高，這可能導致節點數量少的中心化問題，這又對於此類的鏈來說是致命問題，因為外部鏈的資產安全要受到不安全的鏈去管控。

也很好奇ZetaChain當初怎麼解決冷啟動問題的？以及有沒有LST？

## CLI

這部分我今天有大致翻過，了解了有哪些好玩的，這對於之後在操作時會有幫助，但不用全部先跑過一次，有個印象就好！
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->




























## ZetaChain

ZetaChain的POS是基於Cosmos SDK和Comet BFT，可以在各個EVM鏈、Solana、Sui和TON，甚至是比特幣之間進行跨鏈調用

-   向前遷移讓在新區塊鏈加入時通用應用程式無需任何額外工作或修改合約原始碼。
    
-   原生代幣在所有連接的鏈上轉移，用戶可以進行涉及各區塊鏈實際原生資產的交易，而不是使用封裝或合成版本
    
-   開發環境與EVM相容，可以使用熟悉的工具
    
-   通用應用從已連接鏈被呼叫時，僅需在該已連接鏈上支付 Gas 費用，這種gasless的方式，解決了每次合約呼叫都需要在交易雙方支付 gas 費用的問題
    

### 安裝ZetaChain CLI

要先確保有：

-   Node.js`node --version` 檢查
    
-   Yarn`yarn --version` 檢查
    
-   Git`git --version` 檢查
    
-   jq`jq --version` 檢查
    
-   Foundry： `foundryup --version` & `forge --version` 檢查
    

安裝ZetaChain CLI：

```
npm install -g zetachain
```

> ZetaChain CLI是ZetaChain的主要工具，用於進行跨鏈調用、轉移代幣、追蹤跨鏈交易、管理跨多個網路的帳戶、查詢餘額等。

接著運行：

```
zetachain query chains list
```

> 此命令會列出目前連接到ZetaChain的所有鏈，可以確認設定是否正常

會出現下面這張圖：

![Screenshot 2025-11-23 at 4.06.26 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928567712-Screenshot_2025-11-23_at_4.06.26_AM.png)

本地開發最好用Localnet，是一個包含ZetaChain、EVM、Solana、Sui和TON的獨立環境，很方便建立和測試通用應用程式，是最快的方法。

執行Localnet要確保安裝Foundry，如果想運行包含非EVM鏈，可以查看\[Localnet文件\]([https://www.zetachain.com/docs/reference/localnet/](https://www.zetachain.com/docs/reference/localnet/))

在Localnet文件中提到Localnet是ZetaChain的一體化本機開發環境，用於建置、測試和調試通用應用程式，為多個鏈創建節點，並預先部署核心ZetaChain協議合約、ZRC-20代幣，以及Uniswap V2和V3池

使`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，改`yarn zetachain localnet start --chains sui`遇到同樣問題

![Screenshot 2025-11-23 at 8.47.52 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928675064-Screenshot_2025-11-23_at_8.47.52_AM.png)

有點好奇Sui的localnet是怎麽做到的？因為看ㄇSui上很少有可以模擬的localnet。

使`npx zetachain@latest localnet start`列印了Ethereum/ZetaChain/BNB的訊息，不過就卡住了，不確定是結束還是？

後來看文檔，不是卡住，是在監聽，所以是正常的不能關掉！

### 嘗試Hello

參考：\[First Universal Contract\]([https://www.zetachain.com/docs/developers/tutorials/hello](https://www.zetachain.com/docs/developers/tutorials/hello))

```
// SPDX-License-Identifier: MIT

pragma solidity 0.8.26;

import “@zetachain/protocol-contracts/contracts/zevm/interfaces/UniversalContract.sol”;

contract Universal is UniversalContract {

event HelloEvent(string, string);

function onCall(

MessageContext calldata context,

address zrc20,

uint256 amount,

bytes calldata message

) external override onlyGateway {

string memory name = abi.decode(message, (string));

emit HelloEvent("Hello: ", name);

}

}
```

> `onCall`只能`gateway`調用，以確保它僅作為對已連接鏈上調用的響應而被調用，並且您可以信任函數參數的值。這是`onlyGateway` 修飾符強制執行的，該修飾符繼承`UniversalContract`

這個就簡單的hello範例，連接EVM和ZetaChain，靠gateway傳輸，從EVM鏈通過gateway傳到ZetaChain

發送訊息，可以看到需要gateway/receiver/private-key參數

```
PRIVATE_KEY=$(jq -r ‘.private_keys[0]’ ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

```
UNIVERSAL=$(forge create Universal \

--rpc-url http://localhost:8545 \

--private-key $PRIVATE_KEY \

--evm-version paris \

--broadcast \

--json | jq -r .deployedTo) && echo $UNIVERSAL
```

```
GATEWAY_EVM=$(jq -r ‘.[“11155112”].contracts[] | select(.contractType == “gateway”) | .address’ ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

```
npx zetachain evm call \

--rpc <http://localhost:8545> \

--gateway $GATEWAY_EVM \

--receiver $UNIVERSAL \

--private-key $PRIVATE_KEY \

--types string \

--values hello
```

照著上面的流程部署和發送訊息在localnet不太會有問題，發送訊息後在localnet會有：

```
[Ethereum] Processing Called event from 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 to 0x5bf5b11053e734690269C6B9D438F8C9d48F528A

[ZetaChain] Universal contract 0x5bf5b11053e734690269C6B9D438F8C9d48F528A executing onCall (context: {“chainID”:“11155112”,“sender”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”,“senderEVM”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”}), zrc20: 0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe, amount: 0, message: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000)

[ZetaChain] Event from onCall: {“_type”:“log”,“address”:“0x5bf5b11053e734690269C6B9D438F8C9d48F528A”,“blockHash”:“0x40af578e8921789d94d775e8733c80db3edfea934ae24fc4b372c9a6bad838f7”,“blockNumber”:139,“data”:“0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000748656c6c6f3a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000”,“index”:0,“removed”:false,“topics”:[“0x39f8c79736fed93bca390bb3d6ff7da07482edb61cd7dafcfba496821d6ab7a3”],“transactionHash”:“0x9ce7ce063be9718e2020252b6385bc1e6a5ecdbf264dbe5f60db4226b5974cdc”,“transactionIndex”:0}
```

如果說要在testnet上運作的話，就要有錢包，裡面也要有錢錢

需要注意得是`UNIVERSAL`的時候負責部署的地址要有ZETA代幣，才能部署

而在發送訊息時，發送訊息的地址也要有該鏈的代幣，才能支付訊息傳遞的費用

比如，我要從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，我要：

-   部`UNIVERSAL`合約在ZataChain Testnet，這時ZetaChain Testnet的錢包要有ZETA代幣才能部署
    
-   從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，這時Base Sepolia的錢包要有Base Sepolia的ETH才能支付訊息傳遞費用
    

將MetaMask連接到ZetaChain Testnet和Base Sepolia，並確保兩個錢包都有足夠的代幣，以下是我的解法：

-   MetaMask連接ZetaChain Testnet：\[revoke Add ZetaChain to MetaMask\]([https://revoke.cash/learn/wallets/add-network/zetachain](https://revoke.cash/learn/wallets/add-network/zetachain))
    
-   MetaMask連接到Base Sepolia：\[revoke Add Base Sepolia to MetaMask\]([https://revoke.cash/learn/wallets/add-network/base-sepolia](https://revoke.cash/learn/wallets/add-network/base-sepolia))
    
-   透過DC領取ZETA代幣`zeta faucet drip [address]`
    
-   透過\[Google Clound Web3 Ethereum Sepolia Faucet\]([https://cloud.google.com/application/web3/faucet/ethereum/sepolia)領取Ethereum](https://cloud.google.com/application/web3/faucet/ethereum/sepolia\)%E9%A0%98%E5%8F%96Ethereum) Sepolia ETH，再使用跨鏈橋轉到Base Sepolia
    

如果餘額不夠會顯示：

![Screenshot 2025-11-23 at 9.12.53 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928614412-Screenshot_2025-11-23_at_9.12.53_AM.png)

正確會是這樣：

![Screenshot 2025-11-23 at 9.13.01 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928628741-Screenshot_2025-11-23_at_9.13.01_AM.png)

可以在Base Sepolia的區塊鏈瀏覽器查看交易狀態：<[https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57](https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57)\>

可以`npx zetachain query cctx`追蹤跨鏈交易狀態

我`npx zetachain query cctx --hash 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57`：

```
84532 → 7001 ✅ OutboundMined

CCTX: 0xeb314c04807c86709db41d2794bb7a3b9eca77c230717e510035211b81b95fa6

Tx Hash: 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57 (on chain 84532)

Tx Hash: 0x418b305cc89831f24bac419068d8b535a23d836b445820e92655d028fae2bb4c (on chain 7001)

Sender: 0x1Ab8cA7b9f7505a89b4abbfB1B58337CAAF6f71a

Receiver: 0xA78EE9ADD2009d7a004a6c26AE0fe88c47824B01

Message: 0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000
```

-   84532 → 7001 ✅ OutboundMined：表示跨鏈交易已成功從鏈84532發送到鏈7001
    
-   CCTX: 是 ZetaChain 上的跨鏈交易 (CCTX) 的雜湊值，表示此特定跨鏈操作的內部識別碼
    
-   Tx Hash: 分別是來源與目標的tx hash
    
-   Sender: 是發送跨鏈交易的地址
    
-   Receiver: ZetaChain 上接收方合約的地址
    
-   Message: 是跨鏈交易中傳遞的訊息內容，剛剛發送的字串，經過 EVM ABI 編碼 (ABI Encoded) 後的樣子
    

## QWEN

-   在\[qwen聊天室\]([https://chat.qwen.ai/)與\[阿里巴巴Cloud\](https://account.alibabacloud.com/intl/supply\_userinfo/index#/basic/)建立帳號](https://chat.qwen.ai/\)%E8%88%87%5B%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Cloud%5D\(https://account.alibabacloud.com/intl/supply_userinfo/index#/basic/\)%E5%BB%BA%E7%AB%8B%E5%B8%B3%E8%99%9F)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
