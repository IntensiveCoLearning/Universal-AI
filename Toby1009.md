---
timezone: UTC+8
---

# 長在土裡的馬鈴薯

**GitHub ID:** Toby1009

**Telegram:** @Yunizero

## Self-introduction

Bermu DAO Board Member | 
TBA Research Teach Team Leader |
NTU & NTUST Blockchain Club Member |
NTUST CSIE |
Cathay Blockhain RD Intern |
Sui Network Builder

## Notes

<!-- Content_START -->
# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->
## Ominichain是啥

ZRC20文檔中看到 **Ominichain**（全鏈）這個區塊鏈架構概念，很好奇這啥

> Omni代表全部、所有

先講講這Ominichain目標：「讓開發者只寫一份合約，就能控制所有區塊鏈上的資產與數據；讓使用者只用一個錢包，就能操作所有鏈上的應用。」

這與「跨鏈」或「多鏈」有點不同，下面來詳細的說說：

演進過程：從單鏈->全鏈

1.  單鏈：在Ethereum上的資產只能在Ethereum用
    
2.  多鏈與跨鏈橋：為了去Solana或BSC，需要用「跨鏈橋」把資產鎖住，然後在另一遍mint「包裝代幣（Wrapped Token）」（如WBTC），但問題是跨鏈橋風險高，可能被駭客攻擊，而且體驗差，需要不段切換網路，買不同的gas token
    
3.  全鏈（Omnchain），例如ZetaChain：會部署一個「通用合約（Universal Contract），這就是大腦，可以直接指揮Ethereum轉帳ETH，指揮Bitcoin轉帳BTC，不需要真的把BTC般過來，可以「原生的」，而非包裝的，也就是鏈抽象，使用者不需要知道現在後端跑的是啥鏈，Ominichain厲害的就是支援非智能合約鏈，像是Bitcoin，傳統比較困難，但在Ominichain架構可以用evmCall寫邏輯，然後Zetachain會幫忙在Bitcoin上發送原生BTC交易
    

對於開發者來說的好處：只要開發一次（Universal Contract），就可以部署各處。

對於使用者好處：不再強調「把資產跨過去」，而是強調「把訊息傳過去，統一管理」

## ZRC20??

ZRC-20是「其他鏈資產在ZetaChain上的表示」，

所以開發者主要是可以透過這個Universal Omnicahin 智能合約去開發dapp，做到跨鏈交互的一些dapp

像可以做從單一平台建立Omnicahin DeFi協定和dApp（如Omnichain DEX、Omnichain Lending、Ominichain Portfolio Management以及任何涉及多鏈同質話代幣的應用之類的），就變得蠻簡單的，可以像是在同一條鏈（但其實是兩條鏈），看到這時在想有沒有好玩的應用xd

啥幣可以變成ZRC20?已連接鏈的原生gas代幣，跟已列入白名單的ERC20代幣可以存入ZetaChain變成ZRC20代幣歐齁

在存入的過程中，原生/ERC20代幣會被轉移然後鎖定在TSS地址/ERC20託管合約中

> 這邊蠻神奇的Sui上是直接在gateway上，然後EVM的話是TSS、ERC-20 Custody，跟gateway分開，EVM的gateway只搞消息路由/事件，不持幣。而Solana則是介於Sui跟EVM。
> 
> 但如果只是做應用，不一定要理解這，有點太detail

要注意的點是，ZRC20只能透過ZetaChain鑄造，部署在ZetaChain上的ERC20代幣不具備ZRC20的屬性，也無法從ZetaChain上
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->







## Hello App 前端

這個專案是用之前Hello的

前端整題流程會是：

-   連結錢包：能夠用MetaMask，獲取使用者地址、簽署和發送交易
    
-   選擇網路：在UI上提供選單，讓使用者選擇「來源鏈」
    
-   輸入訊息：提供一個輸入框，讓使用者輸入想要跨鏈發送的字串（例如"Hello ZetaChain"）
    
-   發送跨鏈呼叫：
    
    -   這是核心的地方，前端會使用ZetaChain Toolkit 中的 `evmcCall` 函式
        
    -   參數設定：指定接收者（ZetaChain上的合約地址）、編碼後的訊息內容、Gas限制等。
        
    -   使用者在錢包中確認並簽署交易，將訊息發送到ZetaChain上的Universal合約
        
-   追蹤結果：
    
    -   前端會顯示來源鏈的交易Hash
        
    -   接著App會輪詢（Poll）ZetaChain的狀態，查詢跨鏈交易（CCTX）是否已完成
        
    -   最後顯示來源鏈和ZetaChain區塊鏈瀏覽器（Explorer）的連結，證明跨鏈訊息已成功處理。
        

首先，進到之前的Hello專案，然後安裝一下依賴

```
cd hello/frontend
yarn
```

如果沒有的話就重新建立：

```
npx zetachain@latest new --project hello
cd hello/frontend
yarn
```

接著輸入執行：

```
yarn dev
```

會開在： [http://localhost:5173/](http://localhost:5173/)

會先可以連接錢包，然後可以選擇想啥鏈，在旁邊輸入要傳送的訊息後就可以送出，ZetaChain的部分要等一下，然後可以點開看兩條鏈的交易細節

![Screenshot 2025-11-27 at 1.01.05 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-27-1764219766866-Screenshot_2025-11-27_at_1.01.05_PM.png)

下面這個是Base Sepolia

![Screenshot 2025-11-27 at 1.01.18 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-27-1764219883339-Screenshot_2025-11-27_at_1.01.18_PM.png)

下面的是Zetachain testnet

![Screenshot 2025-11-27 at 1.01.25 PM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-27-1764219923148-Screenshot_2025-11-27_at_1.01.25_PM.png)

比較詳細的流程會是：

1.  連接錢包：
    
    1.  前端透過EIP-6963或Dynamic錢包連接，取得ether Signer
        
    2.  不產生鏈上交易
        
2.  選擇來源鏈：
    
    1.  從預設的SUPPORTED\_CHAINS 清單中選擇。
        
    2.  不產生鏈上交易。
        
3.  輸入訊息：
    
    1.  前端做字節長度檢查，確保能安全 ABI 編碼。
        
    2.  不產生鏈上交易。
        
4.  發送跨鏈呼叫（這裡才會上鏈）
    
    1.  前端組裝 evmCall 參數：
        
        1.  receiver: ZetaChain 上的 Hello/Universal 合約地址
            
        2.  types/values: 例如 \[“string”\] / \[“Hello ZetaChain”\]
            
        3.  revertOptions 與 txOptions（如 gasLimit）
            
    2.  使用者在來源鏈的錢包確認與簽署，送出交易到來源鏈的 Gateway 合約。
        
    3.  鏈上交易 1：來源鏈 A 上的交易（evmCall 實際是對 A 鏈 Gateway 的呼叫），回傳 A 鏈 tx hash。
        
5.  ZetaChain 入站處理：
    
    1.  驗證者觀察 A 鏈事件，達到確認數後在 ZetaChain 上投票並執行入站 CCTX。
        
    2.  鏈上交易 2：ZetaChain 上的執行交易（GatewayZEVM 調用你在 ZetaChain 的 Universal/Hello 合約 onCall，把剛才的字串傳遞進去）。
        
6.  追蹤結果（前端）
    
    1.  立即顯示來源鏈 A 的交易哈希與 explorer 連結。
        
    2.  輪詢 ZetaChain 公共 API（以來源鏈 tx hash 查 CCTX），拿到對應的 ZetaChain tx hash 後顯示 ZetaChain explorer 連結。
        
    3.  不一定再有新鏈上交易（除非你的 Universal 合約在 onCall 內又發起出站交易到別的鏈）。
        

常見陷阱

-   錯鏈：錢包須切到支援的 EVM 測試網（如 Arbitrum Sepolia），否則 evmCall 會失敗。
    
-   receiver 地址錯：ZetaChain 上 Hello/Universal 合約地址必須正確且已部署。
    
-   CCTX 等待：ZetaChain 偵測/投票/執行需要時間，UI 輪詢每 15s 是正常做法。
    

> 如果你的 Universal 之後還要「從 ZetaChain 發到 B 鏈」
> 
> -   在 onCall 或後續邏輯中，Universal 調用 GatewayZEVM 發起出站請求。
>     
> -   鏈上交易 3：ZetaChain 上記錄/提交出站請求。
>     
> -   驗證者 TSS 簽名後把交易廣播到 B 鏈。
>     
> -   鏈上交易 4：B 鏈上的最終執行交易完成。
>     
> -   前端可繼續顯示 B 鏈的 explorer 連結（若你的 UI 有追蹤第二段 CCTX）。
>     

來介紹一下主要會用到的工具和方式吧！但只是列個大概xd前端好複雜

首先需要能連接錢包、並能夠簽名

```
const ethersProvider = new ethers.BrowserProvider(selectedProvider.provider);
const signer = (await ethersProvider.getSigner()) as ethers.AbstractSigner;
```

其中 `selectedProvider.provider` 是可以把瀏覽器中注入的錢包物（例如 MetaMask 注入的 `window.ethereum`），包裝成`ethers.js` 看得懂的標準介面

主要負責「讀取」動作：查詢區塊高度、查詢餘額、讀取合約狀態。它知道如何透過 RPC 節點跟區塊鏈溝通

> 注意：單純用 Provider 是不能花錢或改變鏈上狀態的

signer則是代表當前連接的使用者帳戶，它是從 `ethersProvider` 裡面拿出來的。因為 Provider 連接了 MetaMask，所以 Provider 知道你是誰，也擁有**私鑰 (Private Key)** 的控制權（透過 MetaMask 彈窗請求），

主要負責「寫入」動作：當你要轉帳、呼叫 `evmCall` 或與合約互動時，因為需要消耗 Gas 和證明身分，必須由 `signer` 來簽署交易

接著要來建構調用參數，也就是用 `evmCall` 會用到的`evmCallParams` 和 `evmCallOptions`負責告訴 `evmCall` 這個工具包「要做什麼」以及「如果失敗了該咋辦」的詳細設定

簡單來說：

-   `evmCallParams` 是 **「包裹單」**：寫著寄給誰、裡面裝什麼、如果寄送失敗要退貨到哪裡。
    
-   `evmCallOptions` 是 **「寄件手續」**：誰來簽名寄出、要付多少郵資 (Gas)。
    

`evmCallParams` (包裹與退貨設定)

這個物件定義了這次跨鏈訊息的**內容**與**邏輯**。

```
const evmCallParams = {
  // 【收件人】
  // 這是 ZetaChain 上那個 Universal Contract 的地址。
  // 訊息會從您的來源鏈 (如 Sepolia) -> ZetaChain Gateway -> 這個地址。
  receiver: helloUniversalContractAddress,

  // 【包裹內容】(編碼資料)
  // 這裡告訴工具包如何把您的資料打包 (ABI Encoding)。
  // types: ["string"] 表示您要傳送一個字串。
  // values: [stringValue] 這是實際的內容 (例如 "Hello World")。
  types: ["string"],
  values: [stringValue],

  // 【退貨條款】(Revert Options)
  // 這是 ZetaChain 特有的功能。如果跨鏈訊息傳到一半失敗了，該怎麼辦？
  revertOptions: {
    // callOnRevert: false -> 如果失敗，不要觸發來源鏈的回呼函式 (簡單範例通常設 false)。
    callOnRevert: false,

    // revertAddress: ZeroAddress -> 如果有資產要退回，退給誰？
    // ZeroAddress (0x000...) 通常表示 "退回給發送者 (msg.sender)" 或 "不指定"。
    revertAddress: ZeroAddress,

    // revertMessage: "" -> 退回時要附帶什麼訊息？這裡留空。
    revertMessage: "",

    // abortAddress: ZeroAddress -> 如果連退貨都失敗，資產要丟到哪個備用地址？
    abortAddress: ZeroAddress,

    // onRevertGasLimit: 1000000 -> 如果需要執行退貨交易，預留多少 Gas？
    onRevertGasLimit: 1000000,
  },
};
```

> 在簡單的 Hello World 範例中，`revertOptions` 看起來很冗長且大多是空的，但在涉及 **DeFi (轉帳)** 的場景這非常重要。例如您轉了 100 USDT 跨鏈失敗，這個設定決定了錢會不會退回給您。

`evmCallOptions` (執行選項)

這個物件是關於**這筆交易本身**的技術設定。

```
const evmCallOptions = {
  // 【寄件人】
  // 這裡放入我們剛剛解釋過的 signer。
  // 工具包需要它來彈出 MetaMask 視窗讓您簽名。
  signer,

  // 【交易設定】
  txOptions: {
    // gasLimit: 1000000 -> 這是給 "來源鏈" (例如 Ethereum Sepolia) 的 Gas 限制。
    // 這限制了與 ZetaChain Gateway 合約互動時，最多能消耗多少運算量。
    gasLimit: 1000000,
  },
};
```

> 執行 `await evmCall(evmCallParams, evmCallOptions)` 時，實際上發生了這件事：
> 
> 1.  **打包**：工具包根據 `evmCallParams` 把您的字串 “Hello” 包裝好，並寫好退貨地址。
>     
> 2.  **授權**：工具包拿出 `evmCallOptions` 裡的 `signer`。
>     
> 3.  **發送**：`signer` 向區塊鏈發起交易，支付 Gas (由 `txOptions` 限制上限)，把包裹丟給 ZetaChain 的 Gateway 合約。
>     

接著發送跨鏈調用

```
const result = await evmCall(evmCallParams, evmCallOptions);
await result.wait();
 
setConnectedChainTxHash(result.hash);
```

> 調用透過 `result.hash` 發送。 result.hash 是來源 EVM 鏈上的交易哈希，應用程式將其儲存起來，用於瀏覽器連結和追蹤跨鏈狀態

跨鏈中，交易不是瞬間完成的，在來源鏈發送交易後，ZetaChain的節點需要一點時間觀測並處理。

下面已跨國物流追蹤當例子：

-   `connectedChainTxHash` **(寄件單號)**： 這是你在來源鏈（比如在台灣寄出包裹）拿到的**收據號碼**。你只知道貨物交給了物流公司，但不知道貨物實際上飛到哪了。
    
-   `fetch(CCTX_POLLING_URL...)` **(查詢物流 API)**： 你的程式碼拿著這個「寄件單號」，不斷地去問 ZetaChain 的主機（物流中心）：_「請問單號 XXX 的貨物，你們處理好了嗎？」_
    
-   `data.CrossChainTxs...` **(查看運送狀態)**： API 會回傳一大包資料。這行程式碼是在這堆資料裡翻找：
    
    -   _有沒有_ `outbound_params`_？_（意思是有沒有產生「出貨」的動作？）
        
    -   _如果有的話，那個_ `hash` _是多少？_
        
-   `setZetachainTxHash(txHash)` **(更新狀態)**： 一旦找到了 `outbound_params` 裡的 Hash，就代表**貨物已經成功抵達 ZetaChain 並完成了處理**。這時候你把這個新的 Hash 存起來，顯示在 UI 上告訴使用者：「成功入庫！」
    

```
// 1. 發送查詢請求
// CCTX_POLLING_URL 是 ZetaChain 節點提供的 API 網址
// connectedChainTxHash 是你在上一部拿到的來源鏈交易 Hash (例如 0x123...)
const response = await fetch(`${CCTX_POLLING_URL}/${connectedChainTxHash}`);

if (response.ok) {
  // 2. 解析回傳的資料
  const data = (await response.json()) as CrossChainTxResponse;

  // 3. 深入挖掘資料結構 (這行看起來很長是因為資料包了好幾層)
  // CrossChainTxs[0]: 找到這筆跨鏈交易紀錄
  // outbound_params[0]: 找到「出站(Outbound)」的參數
  // hash: 這才是 ZetaChain 鏈上真正的執行 Hash
  const txHash = data.CrossChainTxs?.[0]?.outbound_params?.[0]?.hash;

  // 4. 如果找到了 Hash，就存入 State，UI 就會顯示「成功」
  if (txHash) setZetachainTxHash(txHash);
}
```

有看到 `?.[0]?.` 這很重要，為什麼？

ZetaChain 的跨鏈交易 (CCTX) 狀態很複雜，可能會有以下幾種情況：

-   **Pending**: 節點還在觀察，`outbound_params` 會是空的。
    
-   **Reverted**: 交易失敗正在退款。
    
-   **Mined/Success**: 交易成功，這時候 `outbound_params` 裡才會有東西。
    

所以這行程式碼 `data.CrossChainTxs?.[0]?.outbound_params?.[0]?.hash` 實際上是在做一個**防呆檢查**：只有當交易真正成功並且產生了出站 Hash 時，程式碼才拿得到值，否則它會拿到 `undefined`，程式就不會報錯崩潰。

總之這段就是一個「輪詢氣」，負責在交易送出後，每格幾秒去問一次「好了沒？」，直到拿到ZetaChain那邊的確認單號為止xd

上面就是這個Hello App比較重要的幾點！
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->













## 練習與Sui交互

輸入 \`npx zetachain localnet start --chains sui \`來啟動localnet

會出現下面這畫面，代表好了，也代表localnet正式啟動

![Screenshot 2025-11-26 at 3.24.52 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764098701393-Screenshot_2025-11-26_at_3.24.52_AM.png)

下面這張圖顯示有999.92得餘額，並且env在localnet

localnet在：[http://127.0.0.1:9000](http://127.0.0.1:9000)

這是可以在sui的explorer中輸入的，在explorer看交易比較方便

舉個例子，在suiscan中切換成[http://127.0.0.1:9000](http://127.0.0.1:9000) 可以看到資訊蠻清楚的，有成功顯示這畫面代表localnet搞好了

![Screenshot 2025-11-26 at 3.28.08 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764098915941-Screenshot_2025-11-26_at_3.28.08_AM.png)

接著我要練習call from sui 和call to sui ，徹底學習咋跟sui互動

call from sui：顧名思義就是從sui去呼叫

call to sui：就是呼叫sui

簡單易懂吧？那我先來看看Call from sui 要尬麻

一樣，先建立新專案

```
npx zetachain@latest new --project call
cd call
```

接著安裝依賴

```
yarn
forge soldeer update
```

然後剛剛有開過了localnet，就不贅述了

首先要先把universal smart contract 部署到ZetaChain，合約的部分上次hello的時候說過了

```
GATEWAY_ZETACHAIN=$(jq -r '.["31337"].contracts[] | select(.contractType == "gateway") | .address' ~/.zetachain/localnet/registry.json) && echo $GATEWAY_ZETACHAIN
```

從上面可以看到從31337的gateway那邊拿到拿到gateway的address，名字也叫GATEWAY\_ZETACHAIN，上次的是GATEWAY\_EVM

那這差在哪？

![Screenshot 2025-11-26 at 4.09.42 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764101760622-Screenshot_2025-11-26_at_4.09.42_AM.png)![Screenshot 2025-11-26 at 4.15.49 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764101771391-Screenshot_2025-11-26_at_4.15.49_AM.png)

可以看到31337是ZetaChain的，而11155112是Ethereum的，從名字也可以看出來GATEWAY\_ZETACHAIN / GATEWAY\_EVM

接著去弄弄私鑰，因為要部署要私鑰

```
PRIVATE_KEY=$(jq -r '.private_keys[0]' ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

然後編譯編譯合約

```
forge build
```

沒啥問題就部署Universal合約

```
npx zetachain sui deposit \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x17360c15c10bbc4ebc57e9872f2993dc4376f7f0bb78920fe5fa9ad276ac7f86 \
  --gateway-object 0x9a26d6b6f413228bb120446977a8d8003eceb490cb7afd8921494815adc0a497 \
  --amount 0.001 \
  --chain-id 104
```

輸入這，但要注意！！！

> gateway-package和gateway-object要替換掉，替換成localnet輸出的值
> 
> 在當初zetachain localnet start --chains sui起localnet時就會在各個鏈中搞個gateway負責接收和傳遞訊息！現在填的gateway就是sui上的

下面這張圖就是當初zetachain localnet start --chains sui時部署上去的package的詳細資訊，從suiscan上看

![Screenshot 2025-11-26 at 4.40.34 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764103250752-Screenshot_2025-11-26_at_4.40.34_AM.png)

chain-id的104是啥呢，從前面localnet的輸出上看，就是代表Sui鏈

成功後會長下面這樣

![Screenshot 2025-11-26 at 4.34.05 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764102949675-Screenshot_2025-11-26_at_4.34.05_AM.png)

Transaction hash可以從explore來看

![Screenshot 2025-11-26 at 9.51.40 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764121917762-Screenshot_2025-11-26_at_9.51.40_AM.png)![Screenshot 2025-11-26 at 9.51.47 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764121932158-Screenshot_2025-11-26_at_9.51.47_AM.png)

可以看到是去gateway的deposit，從 [**gateway.move**](https://github.com/zeta-chain/protocol-contracts-sui/blob/develop/sources/gateway.move#L325) 中 可以看到

![Screenshot 2025-11-26 at 9.49.20 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122017596-Screenshot_2025-11-26_at_9.49.20_AM.png)![Screenshot 2025-11-26 at 9.49.07 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122030545-Screenshot_2025-11-26_at_9.49.07_AM.png)

他就將錢錢deposit到他們gateway的小金庫中！

再回到剛剛的地方

![Screenshot 2025-11-26 at 5.07.53 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764122186654-Screenshot_2025-11-26_at_5.07.53_AM.png)

可以看到active-addressess跟sender不同，這時可能會覺得奇怪？咋不同？資金哪來的？

我也是查了又查，發現自己在耍笨，其實是mnemonic後面那串就會做：

-   透過助記詞創建密鑰對生成地址
    
-   去水龍頭領水(faucet)
    

所以就又有地址又有錢啦！但不知道錢錢的部分是不是限定localnet？晚點試試

![Screenshot 2025-11-26 at 5.22.58 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764110395149-Screenshot_2025-11-26_at_5.22.58_AM.png)

上圖是terminal上localnet持續監聽的結果，顯示交易細節，交易成功

寫 `0x777915D031d1e8144c90D025C594b3b8Bf07a08d`存了個token`0x927b167526bAbB9be047421db732C663a0b77B11`，這`0x777915D031d1e8144c90D025C594b3b8Bf07a08d`是誰勒？

![Screenshot 2025-11-26 at 6.05.19 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764111144477-Screenshot_2025-11-26_at_6.05.19_AM.png)

> 小知識：cast run \[tx hash\]可以查交易細節（Trace），可以先透過cast block latest查到最後一筆交易

上面可以看到有三層

從 [**GatewayZEVM.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/GatewayZEVM.sol) 中有這個呼叫的code

![Screenshot 2025-11-26 at 8.43.23 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764118995506-Screenshot_2025-11-26_at_8.43.23_AM.png)

前面先檢查了一些東東，比較重要的是最後

```
if (!IZRC20(zrc20).deposit(target, amount)) revert ZRC20DepositFailed();
```

這邊會呼叫下一層存款，在 [**IZRC20.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/interfaces/IZRC20.sol)中

![Screenshot 2025-11-26 at 9.11.58 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119530766-Screenshot_2025-11-26_at_9.11.58_AM.png)

而他的實作在 [**ZRC20.sol**](https://github.com/zeta-chain/protocol-contracts-evm/blob/develop/contracts/zevm/ZRC20.sol) 中

![Screenshot 2025-11-26 at 9.13.25 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119615704-Screenshot_2025-11-26_at_9.13.25_AM.png)![Screenshot 2025-11-26 at 9.14.39 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764119696288-Screenshot_2025-11-26_at_9.14.39_AM.png)

在deposit中主要做了四件事：

1.  檢查發送者權限
    
2.  鑄幣 (Mint) -> 對應 Trace 的 Transfer 事件
    
3.  發出事件 -> 對應 Trace 的 Deposit 事件
    
4.  回傳 -> 對應 Trace 的 Return
    

以上就對上了Trace的三層結構，總結來說就是會mint代幣出來，然後把目標地址的餘額增加

> 這邊mint的是ZRC20，直接增發，然後在目標地址上的餘額增加
> 
> 但這讓我覺得EVM這種transfer只是在balance\[account\]做加減要有點信任協議誒，像是Sui的代幣是owner\_object，在transfer時就是將該代幣轉移給使用者（地址），只有該代幣使用者（地址）有權限，也就是其他地址無法去操控該代幣，連帶協議也是，也就是餘額不會被偷改。
> 
> 怕會有重入風險，跟群裡大佬討論後覺得主要是看協議合約是否有寫好，有寫好就沒問題，推CEI原則寫的話就比較安全，這我要去學學了！

這邊肯定又會好奇Trace中deposit 是從 `0x735b14bb79463307aacbed86daf3322b1e6226ab` 傳到目標地址的，那這是啥勒

從ZRC20合約中deposit function內有看到

```
 emit Deposit(abi.encodePacked(FUNGIBLE_MODULE_ADDRESS), to, amount);
```

其中的FUNGIBLE\_MODULE\_ADDRESS，是一個由協議維護的、固定的地址，總而言之就是協議地址

![Screenshot 2025-11-26 at 9.30.38 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-26-1764120756536-Screenshot_2025-11-26_at_9.30.38_AM.png)

也就是從協議中把代幣deposit到目標地址！

小結：從前面的過程中，可以發現，call from sui 的deposit主要就是，將sui 轉到sui上的gateway放進裡面的小金庫，然後zetachain上會由協議mint新代幣，並且轉到目標地址上，而這個目標地址是剛部署在zetachain上的Universal合約。其中sui上的gateway是在建立localnet時就部署上去了。

不過咋Universal存了錢沒反應？？？

其實可以換成呼叫deposit-and-call的方式，相比於deposit，他還會觸發Universal的onCall

```
npx zetachain sui deposit-and-call \
  --mnemonic "grape subway rack mean march bubble carry avoid muffin consider thing street" \
  --receiver $UNIVERSAL \
  --gateway-package 0x17360c15c10bbc4ebc57e9872f2993dc4376f7f0bb78920fe5fa9ad276ac7f86 \
  --gateway-object 0x9a26d6b6f413228bb120446977a8d8003eceb490cb7afd8921494815adc0a497 \
  --amount 0.001 \
  --chain-id 104 \
  --types string \
  --values hello
```

> 同樣的gateway-package/gateway-object也要改

所以deposit整體流程再次總結：

-   **Sui 世界**：你 -> 調用 **Sui Gateway (Move)** -> 錢被鎖定在 Sui。 _(這裡是你 CLI 指令_ `zetachain sui deposit` _發生的地方)_ ↓ _(ZetaChain 的驗證節點觀察到這一幕)_ ↓
    
-   **ZetaChain 世界**：驗證節點（有效性投票，多數同意後更新CCTX） -> 調用 **ZEVM Gateway (Solidity)** -> 錢被 Mint 出來 -> 轉給 **Universal 合約** 。
    

> 追蹤 CCTX 需要使用入站交易雜湊值查詢 ZetaChain 的 Cosmos SDK HTTP API，以取得 CCTX 雜湊值。如果一個 CCTX 產生了另一個 CCTX（例如，入站交易產生了出站交易），則可以使用第一個 CCTX 哈希值作為入站哈希值來獲取第二個 CCTX 哈希值。

## Universal資產和Gateway圖解

我覺得[Universal Asset overview](https://www.zetachain.com/docs/developers/standards/overview)的圖畫的很好，很傳神哈哈：

![https://excalidraw.com/#json=dQJisu_uJ0N8T6IPi2m0E,PJU63ktFfbi1WsfAXsompA](https://www.zetachain.com/docs/_next/image/?url=%2Fdocs%2F_next%2Fstatic%2Fmedia%2Ftutorials-nft.1d7d1ca2.png&w=3840&q=75)

上面這張圖是以NFT為例

或是 [**qwe638853**](https://github.com/IntensiveCoLearning/Universal-AI/blob/main/qwe638853.md)的筆記的圖：

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764097834061-image.png)

> 圖是用Excalidraw畫

其實就跟我前面提到的一樣
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->































## `Error問題解決 zetachain localnet start --chains sui`

關於使用`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，找到問題為什麼zetachain的sui localnet弄不起來了

從錯誤訊息中看到是沒有issue\_message\_context這個function，有看到是從/usr/local/share/localnet這邊呼叫的

查看後看到有protocol-contracts-sui/，裡面是放move合約的，然後裡面沒有issue\_message\_context這個function

從toml可以發現確實就是呼叫這合約

接著我去查zetachain localness src chains的sui，發現裡面有下載和呼叫protocol-contracts-sui/ 從repo中，然後我從上面clone下來後發現咋clone下來的有issue\_message\_context，執行後確實成功跑起來sui localnet了

這時我就好奇咋之前自動下載的會出問題，一看發現：

<[https://github.com/zeta-chain/protocol-contracts-sui](https://github.com/zeta-chain/protocol-contracts-sui)\> 他的main沒有issue\_message\_context，只有develop有，develop也是default，但自動抓會抓到main

總結就是：CLI指令會自動從repo抓和呼叫main branch的檔案，但是正確是要從develop抓才不會報錯，蠻神奇的

## Qwen

要先註冊阿里巴巴雲端，然後綁信用卡那些，我用u卡，他會轉1u出去再轉回來確定是否是正確的。

在 [Qwen API](https://modelstudio.console.alibabacloud.com/?tab=api#/api) 有介紹咋獲取API，首先我是在新加坡的playground弄的api，像這樣

![Screenshot 2025-11-25 at 9.33.32 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034421121-Screenshot_2025-11-25_at_9.33.32_AM.png)

[API參考](https://modelstudio.console.alibabacloud.com/?tab=api#/api/?type=model&url=2712576)中有python配置參考那些，根據配置先將剛剛的API key弄到環境變數DASHSCOPE\_API\_KEY，避免直接明文上去

然後URL就貼新加坡的。

![Screenshot 2025-11-25 at 9.34.15 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034509335-Screenshot_2025-11-25_at_9.34.15_AM.png)

成功後顯示：

![Screenshot 2025-11-25 at 9.36.13 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-25-1764034585498-Screenshot_2025-11-25_at_9.36.13_AM.png)

這樣就代表能用api了

## ZetaChain架構理解

### 基礎

ZetaChain基於Consmos SDK和Comet BFT的POS，這昨天有寫，主要特性是出塊快！以及確定快！

也就是交易到打包都快，然後不太會有MEV以及區塊重組之類的問題（類似於Sui就不太會有MEV）

並且可擴展至約300個節點，以我的理解來說還行，像是Sui就只有100個節點@@ 但好奇ZetaChain質押要多少？

然後可以透過BLS門檻簽名技術升級，讓更多節點加入，TPS可達100左右。好奇門檻技術咋升級的？會不會有衝突？

### 組成

ZetaChain組成：

-   ZetaCore：
    
    -   負責生成區塊鏈
        
    -   負責維護狀態機，也就是區塊鏈本身的帳本與邏輯運作
        
-   ZetaClient：
    
    -   負責觀察連接鏈（如Ethereum,Bitcoin,Solana等)上的事件
        
    -   負責簽署發送到這些連接鏈的外部交易
        

這兩個組成一個驗證者節點，由節點運營商搞，只要有足夠的資產質押就能成為節點運營商

總而言之可以發現有兩個角色，有點像是Ethereum的驗證者有多個角色一樣，但是每個驗證者不一定都會一直全部角色都會處理到，像是有出塊倡議者、證明者，以及同步委員會，這三個組成驗證者，而只有證明者比較常會是運作的，這也是基礎獎勵來源，其他兩個偶爾有，但獎勵不錯。

再來細講一下這兩個角色具體在幹麻：

-   核心驗證者（Core Validators）：
    
    -   職責：參與區塊生成和共識過程
        
    -   機制：使用Comet BFT 共識協議。驗證者對區塊提案進行投票，投票權重與質押或被委託的代幣（ZETA）數量成正比
        
    -   要求：需要時刻保持在線，以參與不斷增長的區塊生產
        
-   觀察者-簽署者驗證者（Observer-Signer Validators）：
    
    -   觀察者：
        
        -   透過運行連接鏈的全節點，監控外部鏈(如Bitcoin或Ethereum）上特定地址的相關交易、事件或狀態
            
    -   簽署者：
        
        -   擁有一部分密鑰分片。ZetaChain集體持有一組標準的ECDSA/EdDSA密鑰（因為這要看不同鏈的密鑰，像是Bitcoin/Ethereum就是ECDSA，而Solana/Sui就是EdDSA），用於與外部鏈進行驗證交互
            
        -   去中心化簽名：密鑰分再多個簽署者手中，只有當絕對多數的節點共同簽名時，才能代表ZetaChain在外部鏈上執行操作（例如轉移比特幣）
            
        -   安全性：沒有任何單一實體或少數節點可以單獨代表ZetaChain簽署訊息，確保了資產的安全性和去中心化
            

簡單來說就是，透過觀察者去監控其他鏈，然後將這些訊息傳到ZetaChain上面，會這樣做的原因是鏈上不會自動更新狀態，要透過外部去push才行，而觀察者就是負責觀察，然後傳到ZetaChain上面改變ZetaChain上面的狀態，也就是輸入，類似於預言機(Oracle）

而簽署者是輸出，將ZetaChain的訊息傳入到外部鏈，像是當ZetaChain上的智能合約決定要在外部鏈執行操作時（例如用戶想把資產提領回Ethereum，或是在外部鏈上調用合約），簽署者會利用門檻簽名（TSS）共同生成一個簽名去簽，而這個簽名會被廣播到外部鏈上，完成資產轉移或合約執行。

之所以要使用門檻簽名，是因為至少要多個節點承認此操作並進行操作才行，不然只有一個節點就能轉移資產實在有點危險xd

因為這兩個角色核心驗證者和觀察者-簽署者驗證者都是同個驗證者，所以會好奇所需硬體資源，以及質押量會不會很大？

硬體資源，不只是要跑ZetaChain節點，還要外部鏈全節點

而質押則是確保網路安全，不確定這部分要多少？

如果說這兩者所需要的門檻都很高，那加入驗證者的門檻自然就更高，這可能導致節點數量少的中心化問題，這又對於此類的鏈來說是致命問題，因為外部鏈的資產安全要受到不安全的鏈去管控。

也很好奇ZetaChain當初怎麼解決冷啟動問題的？以及有沒有LST？

## CLI

這部分我今天有大致翻過，了解了有哪些好玩的，這對於之後在操作時會有幫助，但不用全部先跑過一次，有個印象就好！
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->








































## ZetaChain

ZetaChain的POS是基於Cosmos SDK和Comet BFT，可以在各個EVM鏈、Solana、Sui和TON，甚至是比特幣之間進行跨鏈調用

-   向前遷移讓在新區塊鏈加入時通用應用程式無需任何額外工作或修改合約原始碼。
    
-   原生代幣在所有連接的鏈上轉移，用戶可以進行涉及各區塊鏈實際原生資產的交易，而不是使用封裝或合成版本
    
-   開發環境與EVM相容，可以使用熟悉的工具
    
-   通用應用從已連接鏈被呼叫時，僅需在該已連接鏈上支付 Gas 費用，這種gasless的方式，解決了每次合約呼叫都需要在交易雙方支付 gas 費用的問題
    

### 安裝ZetaChain CLI

要先確保有：

-   Node.js`node --version` 檢查
    
-   Yarn`yarn --version` 檢查
    
-   Git`git --version` 檢查
    
-   jq`jq --version` 檢查
    
-   Foundry： `foundryup --version` & `forge --version` 檢查
    

安裝ZetaChain CLI：

```
npm install -g zetachain
```

> ZetaChain CLI是ZetaChain的主要工具，用於進行跨鏈調用、轉移代幣、追蹤跨鏈交易、管理跨多個網路的帳戶、查詢餘額等。

接著運行：

```
zetachain query chains list
```

> 此命令會列出目前連接到ZetaChain的所有鏈，可以確認設定是否正常

會出現下面這張圖：

![Screenshot 2025-11-23 at 4.06.26 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928567712-Screenshot_2025-11-23_at_4.06.26_AM.png)

本地開發最好用Localnet，是一個包含ZetaChain、EVM、Solana、Sui和TON的獨立環境，很方便建立和測試通用應用程式，是最快的方法。

執行Localnet要確保安裝Foundry，如果想運行包含非EVM鏈，可以查看\[Localnet文件\]([https://www.zetachain.com/docs/reference/localnet/](https://www.zetachain.com/docs/reference/localnet/))

在Localnet文件中提到Localnet是ZetaChain的一體化本機開發環境，用於建置、測試和調試通用應用程式，為多個鏈創建節點，並預先部署核心ZetaChain協議合約、ZRC-20代幣，以及Uniswap V2和V3池

使`npx zetachain localnet start --chains sui`啟用本地開發環境遇`[Sui] Failed to issue MessageContext: Error: No function was found with function name issue_message_context`錯誤，改`yarn zetachain localnet start --chains sui`遇到同樣問題

![Screenshot 2025-11-23 at 8.47.52 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928675064-Screenshot_2025-11-23_at_8.47.52_AM.png)

有點好奇Sui的localnet是怎麽做到的？因為看ㄇSui上很少有可以模擬的localnet。

使`npx zetachain@latest localnet start`列印了Ethereum/ZetaChain/BNB的訊息，不過就卡住了，不確定是結束還是？

後來看文檔，不是卡住，是在監聽，所以是正常的不能關掉！

### 嘗試Hello

參考：\[First Universal Contract\]([https://www.zetachain.com/docs/developers/tutorials/hello](https://www.zetachain.com/docs/developers/tutorials/hello))

```
// SPDX-License-Identifier: MIT

pragma solidity 0.8.26;

import “@zetachain/protocol-contracts/contracts/zevm/interfaces/UniversalContract.sol”;

contract Universal is UniversalContract {

event HelloEvent(string, string);

function onCall(

MessageContext calldata context,

address zrc20,

uint256 amount,

bytes calldata message

) external override onlyGateway {

string memory name = abi.decode(message, (string));

emit HelloEvent("Hello: ", name);

}

}
```

> `onCall`只能`gateway`調用，以確保它僅作為對已連接鏈上調用的響應而被調用，並且您可以信任函數參數的值。這是`onlyGateway` 修飾符強制執行的，該修飾符繼承`UniversalContract`

這個就簡單的hello範例，連接EVM和ZetaChain，靠gateway傳輸，從EVM鏈通過gateway傳到ZetaChain

發送訊息，可以看到需要gateway/receiver/private-key參數

```
PRIVATE_KEY=$(jq -r ‘.private_keys[0]’ ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

```
UNIVERSAL=$(forge create Universal \

--rpc-url http://localhost:8545 \

--private-key $PRIVATE_KEY \

--evm-version paris \

--broadcast \

--json | jq -r .deployedTo) && echo $UNIVERSAL
```

```
GATEWAY_EVM=$(jq -r ‘.[“11155112”].contracts[] | select(.contractType == “gateway”) | .address’ ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

```
npx zetachain evm call \

--rpc <http://localhost:8545> \

--gateway $GATEWAY_EVM \

--receiver $UNIVERSAL \

--private-key $PRIVATE_KEY \

--types string \

--values hello
```

照著上面的流程部署和發送訊息在localnet不太會有問題，發送訊息後在localnet會有：

```
[Ethereum] Processing Called event from 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 to 0x5bf5b11053e734690269C6B9D438F8C9d48F528A

[ZetaChain] Universal contract 0x5bf5b11053e734690269C6B9D438F8C9d48F528A executing onCall (context: {“chainID”:“11155112”,“sender”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”,“senderEVM”:“0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266”}), zrc20: 0x2ca7d64A7EFE2D62A725E2B35Cf7230D6677FfEe, amount: 0, message: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000)

[ZetaChain] Event from onCall: {“_type”:“log”,“address”:“0x5bf5b11053e734690269C6B9D438F8C9d48F528A”,“blockHash”:“0x40af578e8921789d94d775e8733c80db3edfea934ae24fc4b372c9a6bad838f7”,“blockNumber”:139,“data”:“0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000748656c6c6f3a2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000”,“index”:0,“removed”:false,“topics”:[“0x39f8c79736fed93bca390bb3d6ff7da07482edb61cd7dafcfba496821d6ab7a3”],“transactionHash”:“0x9ce7ce063be9718e2020252b6385bc1e6a5ecdbf264dbe5f60db4226b5974cdc”,“transactionIndex”:0}
```

如果說要在testnet上運作的話，就要有錢包，裡面也要有錢錢

需要注意得是`UNIVERSAL`的時候負責部署的地址要有ZETA代幣，才能部署

而在發送訊息時，發送訊息的地址也要有該鏈的代幣，才能支付訊息傳遞的費用

比如，我要從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，我要：

-   部`UNIVERSAL`合約在ZataChain Testnet，這時ZetaChain Testnet的錢包要有ZETA代幣才能部署
    
-   從Base Sepolia發送訊息到ZetaChain Testnet`UNIVERSAL`合約，這時Base Sepolia的錢包要有Base Sepolia的ETH才能支付訊息傳遞費用
    

將MetaMask連接到ZetaChain Testnet和Base Sepolia，並確保兩個錢包都有足夠的代幣，以下是我的解法：

-   MetaMask連接ZetaChain Testnet：\[revoke Add ZetaChain to MetaMask\]([https://revoke.cash/learn/wallets/add-network/zetachain](https://revoke.cash/learn/wallets/add-network/zetachain))
    
-   MetaMask連接到Base Sepolia：\[revoke Add Base Sepolia to MetaMask\]([https://revoke.cash/learn/wallets/add-network/base-sepolia](https://revoke.cash/learn/wallets/add-network/base-sepolia))
    
-   透過DC領取ZETA代幣`zeta faucet drip [address]`
    
-   透過\[Google Clound Web3 Ethereum Sepolia Faucet\]([https://cloud.google.com/application/web3/faucet/ethereum/sepolia)領取Ethereum](https://cloud.google.com/application/web3/faucet/ethereum/sepolia\)%E9%A0%98%E5%8F%96Ethereum) Sepolia ETH，再使用跨鏈橋轉到Base Sepolia
    

如果餘額不夠會顯示：

![Screenshot 2025-11-23 at 9.12.53 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928614412-Screenshot_2025-11-23_at_9.12.53_AM.png)

正確會是這樣：

![Screenshot 2025-11-23 at 9.13.01 AM.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/Toby1009/images/2025-11-23-1763928628741-Screenshot_2025-11-23_at_9.13.01_AM.png)

可以在Base Sepolia的區塊鏈瀏覽器查看交易狀態：<[https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57](https://sepolia.basescan.org/tx/0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57)\>

可以`npx zetachain query cctx`追蹤跨鏈交易狀態

我`npx zetachain query cctx --hash 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57`：

```
84532 → 7001 ✅ OutboundMined

CCTX: 0xeb314c04807c86709db41d2794bb7a3b9eca77c230717e510035211b81b95fa6

Tx Hash: 0x59a909e73fc0463a2bcf43382289b03106e764e626e8bd55705432dee4cfeb57 (on chain 84532)

Tx Hash: 0x418b305cc89831f24bac419068d8b535a23d836b445820e92655d028fae2bb4c (on chain 7001)

Sender: 0x1Ab8cA7b9f7505a89b4abbfB1B58337CAAF6f71a

Receiver: 0xA78EE9ADD2009d7a004a6c26AE0fe88c47824B01

Message: 0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000568656c6c6f000000000000000000000000000000000000000000000000000000
```

-   84532 → 7001 ✅ OutboundMined：表示跨鏈交易已成功從鏈84532發送到鏈7001
    
-   CCTX: 是 ZetaChain 上的跨鏈交易 (CCTX) 的雜湊值，表示此特定跨鏈操作的內部識別碼
    
-   Tx Hash: 分別是來源與目標的tx hash
    
-   Sender: 是發送跨鏈交易的地址
    
-   Receiver: ZetaChain 上接收方合約的地址
    
-   Message: 是跨鏈交易中傳遞的訊息內容，剛剛發送的字串，經過 EVM ABI 編碼 (ABI Encoded) 後的樣子
    

## QWEN

-   在\[qwen聊天室\]([https://chat.qwen.ai/)與\[阿里巴巴Cloud\](https://account.alibabacloud.com/intl/supply\_userinfo/index#/basic/)建立帳號](https://chat.qwen.ai/\)%E8%88%87%5B%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Cloud%5D\(https://account.alibabacloud.com/intl/supply_userinfo/index#/basic/\)%E5%BB%BA%E7%AB%8B%E5%B8%B3%E8%99%9F)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
