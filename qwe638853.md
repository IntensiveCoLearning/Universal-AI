---
timezone: UTC+8
---

# 林威立

**GitHub ID:** qwe638853

**Telegram:** @qwe638853

## Self-introduction

認識一些Zetachain

## Notes

<!-- Content_START -->
# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->
昨天用Qwen API簡單完成了結構化輸出的功能，那今天來研究更進階的Qwen-Agent

## Qwen Agent

Qwen Agent是一個框架可以將LLM變成一個可以真的幫你做一些行動、決策的AI，也就是說你給他工具（像是調用API、觸發某function），他可以根據使用者的回答自己去做決定要使用那些工具

那先從他的範例在做什麼開始了解，那`llm_cfg`基本上就是設定LLM的來源以及針對LLM本身的一些參數微調，像`top_p`越高就表示生成的回答越多樣化，反之就越固定。

```
llm_cfg = {
    'model': 'qwen-plus',
    'model_server': 'https://dashscope-intl.aliyuncs.com/compatible-mode/v1',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    'generate_cfg': {
        'top_p': 0.8
    }
}
```

再來定義了System Prompt，那要注意這邊都還只是參數，等等才會創建Agent的實例

```
system = 'According to the user\'s request, you first draw a picture and then automatically run code to download the picture ' + \ 'and select an image operation from the given document to process the image'
```

那在往下看，他創建了Agent等等會使用到的工具，那只要填寫對於這個工具的描述（`description`參數）、要求參數（`parameters`參數）、工具實際邏輯（`def call()`）就算完成創建工具的流程  
  
另外翻了一下[Source code](https://github.com/QwenLM/Qwen-Agent/blob/main/qwen_agent/tools/base.py)，他是強制要實作這個`call`的function，而他在調用`call`之前，會用一個叫做`_verify_json_format_args()`去檢查參數是否符合規範的`parameters`

```
# 創建一個叫my_image_gen的工具
@register_tool('my_image_gen')
class MyImageGen(BaseTool):
    description = 'AI painting (image generation) service, input text description, and return the image URL drawn based on text information.'
    parameters = [{
        'name': 'prompt',
        'type': 'string',
        'description': 'Detailed description of the desired image content, in English',
        'required': True
    }]

    def call(self, params: str, **kwargs) -> str:
        prompt = json5.loads(params)['prompt']
        prompt = urllib.parse.quote(prompt)
        return json.dumps(
            {'image_url': f'https://image.pollinations.ai/prompt/{prompt}'},
            ensure_ascii=False)

```

那接下來，工具有了、參數有了、Prompt有了，就可以來創建Agent的實例了。用`Assistant()`並把參數都塞進去，最後補充一下，這邊`function_list`表示我們的Agent可以使用的工具

```

tools = ['my_image_gen', 'code_interpreter']  
bot = Assistant(llm=llm_cfg,system_message=system,function_list=tools)
```

創建之後，用個無限迴圈來啟用我們的Agent，直接可以在Terminal去對話

```
messages = []
while True:
    query = input('user question: ')
    messages.append({'role': 'user', 'content': query})
    response = []
    for response in bot.run(messages=messages):
        print('bot response:', response)
    messages.extend(response)
```

那執行結果如下  

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-12-01-1764611956766-image.png)

生出來的貓還挺可愛的

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-12-01-1764611882375-image.png)

順帶一提它其實不只有`Assistant()`這個實例可以去用，他還有像是`GroupChat`可以搞個Agent群聊或是也能把任務拆分成多個子任務並交由不同 Agent 負責，再串接成完整的 workflow。在[這裡](https://github.com/QwenLM/Qwen-Agent/blob/main/docs/agent_cn.md)可以看更多

### 交易hash查詢Agent實作

簡單實作了一個只要丟交易hash進去，就會自動去調用Etherscan去查詢這交易hash的詳細資訊並分析

那其實最主要要實作的只有tool，那我們`call()`邏輯也非常簡單，就是將hash透過Etherscan的API去查詢詳細資訊而已，下面是實際的code

```
@register_tool('ethereum_transaction_query')
class EthereumTransactionQuery(BaseTool):
    description = 'Query Ethereum transaction'
    parameters = [{
        'name': 'transaction_hash',
        'type': 'string',
        'description': 'Transaction hash to query',
        'required': True
    }]
    def call(self, params: str, **kwargs) -> str:
        transaction_hash = json5.loads(params)['transaction_hash']
        api_key = os.getenv("ETHERSCAN_API_KEY")
        if not api_key:
            return json.dumps({"error": "Missing ETHERSCAN_API_KEY in environment variables"})

        # 查交易 (eth_getTransactionByHash)
        url = (
            "https://api.etherscan.io/v2/api"
            f"?chainid=1"
            f"&module=proxy"
            f"&action=eth_getTransactionByHash"
            f"&txhash={transaction_hash}"
            f"&apikey={api_key}"
        )

        try:
            res = requests.get(url).json()
            return json.dumps(res, ensure_ascii=False)
        except Exception as e:
            return json.dumps({"error": str(e)})
```

那效果如下圖  

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-12-01-1764611844014-image.png)

### 小結

實作了一個簡單的Agent，明天看能不能努力搞個會發交易的Agent
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->

那今天就先來嘗試一下Qwen API，有什麼功能，上次只有簡單發Request，但仔細研究一下其實蠻多參數可以去微調

## Qwen API

那就先依據[Qwen API文檔](https://www.alibabacloud.com/help/zh/model-studio/qwen-api-reference)的範例，直接執行看看，讓他跟我介紹Zetachain

```
async function main() {
    const completion = await openai.chat.completions.create({
        model: "qwen-plus",  
        messages: [
            { role: "system", content: "You are a Zetachain developer." },
            { role: "user", content: "什麼是Zetachain?" }
        ],
    });
    console.log(JSON.stringify(completion))
}
```

那執行結果如下

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-30-1764525774480-image.png)

## 結構化輸出

看到他有個功能是可以將回答強制以JSON回應，那這個功能可以讓AI去自動生成指令，這樣如果我們之後要做個打打字他就會幫我轉帳的AI agent，這個功能還是很重要的，\*\*讓AI 回答不再是給人看的，而是給程式直接執行的。\*\*

下面是實際的code，主要要做的事就是加上`response_format: {"type": "json_object"}`以及在Prompt裡面規範需要回傳的結構化格式

```
async function main() {
    const completion = await openai.chat.completions.create({
        model: "qwen-plus",  
        response_format: {"type": "json_object"},
        messages: [
            { role: "system", content: "You are a Zetachain developer. your response should be in JSON format. { action: transfer, from: Ethereum, to: Zetachain, amount: 0.1 }" },
            { role: "user", content: "我要轉0,1ETH從Ethereum到Zetachain" }
        ],
    });
    console.log(JSON.stringify(completion.choices[0].message.content))
}
```

那我改成只輸`content`的話，就會得到一個乾淨俐落，符合我們規定格式的JSON輸出，結果如下

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-30-1764525829351-image.png)

##   
小結

今天算是簡單玩了一下Qwen的API，雖然我只用到了結構化輸出的功能，但還有很多酷功沒試，只是就先以之後黑客松可能會用到技術為主，畢竟時間有限哈哈
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-30
<!-- DAILY_CHECKIN_2025-11-30_START -->


今天來弄一點實作的東西，因為過幾個禮拜有黑客松，所以今天來嘗試搞個簡單的Universal vault，可能可以作為黑客松的題目或單純當作練習寫個Universal App也不錯

## Universal Vault

那先簡單定義我們的Universal Vault是什麼，可以先參考Universal App的定義

> Universal App是在Zetachain上部屬的智能合約，可以接受來自任何鏈的合約呼叫、訊息、Token轉移

在這個基礎上，我們可以這樣來定義**Universal Vault**

> Universal Vault 是部署在 ZetaChain 上的金庫合約，用戶可以從任意鏈儲存資產及提取資產，而 Vault 則能透過跨鏈訊息在各鏈上進行投資與策略操作。

### 如何實作

那我的第一步就是先用，Zetachain的CLI去創建一個Universal App的框架再去修改，藉此提高開發速度。

那這裡我選擇hello這個範例合約去修改

```
npx zetachain@latest new --project hello
```

那一開始我們要決定Vault裡存放的底層資產是什麼，那我最後決定以ETH.ETH為主（主要是為了方便測試），但其實做到這邊就有很多可以變化的點了，如果**Vault支援多資產**那麼的邏輯會變得很複雜，但就不用一直Swap，相反地，如果只接受ETH.ETH，那 Vault 的邏輯會單純很多，但代價是**所有進到 Hub 的 ZRC20 資產，都必須先在 Zeta 上被換成 USDC.BASESEP，才能存入 Vault。**

那我們用ERC4626直接去實作出一個可以從任何鏈去存入金庫及提款的簡單小金庫，那先初始化必要的參數

```
constructor(
	address _asset,          // Vault underlying asset: ZRC20 on ZetaChain
	string memory _name,     // Vault Token name
	string memory _symbol,   // Vault Token symbol
	address _uniswapRouter   // UniswapV2 Router on ZetaChain
)
	ERC20(_name, _symbol)
	ERC4626(IERC20(_asset))
{
	require(_uniswapRouter != address(0), "Universal: invalid router");
	uniswapRouter = _uniswapRouter;
}
```

那我們核心邏輯很簡單，因為參數會包再Message裡面的方式傳進來，所以就用action的參數去區分使用者的行為

```
function onCall(
	MessageContext calldata context,
	address zrc20,
	uint256 amount,
	bytes calldata message
) external override onlyGateway {
	// 解析 message 
	(uint8 action, bytes memory payload) = abi.decode(message, (uint8, bytes));
	// 假設 action 是 DEPOSIT
	if (action == uint8(Action.DEPOSIT)) {
		uint256 assetAmount;
		// 如果 zrc20 剛好是底層資產，則直接使用
		if (zrc20 == asset()) {
			assetAmount = amount;
		// 如果 zrc20 不是底層資產，則需要使用 UniswapV2 Router Swap成底層資產
		} else {
			assetAmount = SwapHelperLib.swapExactTokensForTokens(
				uniswapRouter,
				zrc20,
				amount,
				asset(),
				0
			);
		}
		// 調用 _handleDeposit 處理 deposit
		_handleDeposit(context, assetAmount);
	// 假設 action 是 WITHDRAW
	} else if (action == uint8(Action.WITHDRAW)) {
		// 調用 _handleWithdraw 處理 withdraw
		_handleWithdraw(context, payload);
	} else {
		revert("UniversalVault: unknown action");
	}
}
```

在實作跨鏈存款的時候，我一開始在 `deposit` 這段卡了滿久。

主要是我一開始忘記了一件關鍵的事情：

> 在 Zetachain 的流程裡，資產會在呼叫 `onCall` 之前，就先由 Gateway 打進 Vault 合約。

如果我在 `onCall` 裡還是直接呼叫 ERC4626 的 `deposit()` / `mint()`，就會出現問題，因為標準的 ERC4626 `deposit()` 流程是：

1\. 先根據 `assets` 計算 `shares`

2\. 然後呼叫 `transferFrom`，**把使用者的資產從使用者地址拉進 Vault**

但在我們的情境中，**資產其實已經在 Vault 裡了**，多呼叫一次 `deposit()` 反而會再嘗試從 `msg.sender`（Gateway）那邊拉資產，導致整個交易 revert。

在 `onCall` 裡不要再用 `deposit()` / `mint()`，改成根據 Vault 當前的 `totalAssets` / `totalSupply` 自己計算應該給多少 `shares`，然後直接 `_mint(user, shares)`，把 share 發給 `context.senderEVM`。

下面是實際的code

```
function _handleDeposit(
	MessageContext calldata context,
	uint256 amount
) internal {
	require(amount > 0, "Universal: zero deposit");
	address user = context.senderEVM;
	require(user != address(0), "Universal: no senderEVM");
	uint256 shares;
	uint256 _totalSupply = totalSupply();
	uint256 _totalAssets = totalAssets();
	// 計算轉入前的資產餘額（減去新轉入的 amount）
	uint256 assetsBeforeDeposit = totalAssets >= amount ? totalAssets - amount : 0;
	// 完全空的 vault：第一次存款，使用 1:1 比例
	if (_totalSupply == 0 && assetsBeforeDeposit == 0) {
		shares = amount;
	} else {
	   shares = previewDeposit(assetsBeforeDeposit);
	}
	require(shares > 0, "Universal: zero shares");
	// 直接 mint shares，因為資產已經在合約中
	_mint(user, shares);
	emit CrossDeposit(user, amount, context.chainID, context.sender);
}
```

那我這邊用zetachain的cli從Ethereum去調用我們的Universal合約，這邊payload是0x是因為我的payload是設計`_handleWithdraw`的參數，`_handleDeposit`沒用到，所以直接傳入0x即可

```
npx zetachain evm deposit-and-call \
  --rpc http://localhost:8545 \
  --chain-id 11155112 \
  --gateway $GATEWAY_ETHEREUM \
  --amount 1 \
  --receiver $UNIVERSAL \
  --private-key $PRIVATE_KEY \
  --types uint8 bytes \
  --values 0 0x
```

那我們用localnet進行測試，那上面指令執行後，可以檢查localnet的log，確保我們的合約事件有正確發出

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-30-1764513937449-image.png)

那我們也可以`cast`去讀取合約狀態檢驗我們剛剛有確實改變狀態，下面是檢查User share數量的指令

```
cast call $UNIVERSAL "balanceOf(address)(uint256)" \
  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 \
  --rpc-url $ZETA_RPC
```

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-30-1764513959619-image.png)

## 小結

其實我今天在實作 `deposit` 的部分卡了蠻久，所以還來不及把 `withdraw` 的流程完整測完。不過目前至少跨鏈存款（deposit）的功能已經可以從 Ethereum 端透過 ZetaChain CLI 觸發，並在 ZetaChain 上正確完成資產入庫與 share 的鑄造。

在設計這個簡單 Vault 的過程中，其實有蠻多值得深思的地方。例如，目前的設計是只有在ZetaChain 上鑄造 share，等於所有share都統一在 ZetaChain 這條鏈上做記帳管理，其他外部鏈只負責「進出金流」，不直接持有 share。

理論上，我也可以選擇在每一條來源鏈都各自發行一份 share，變成「多鏈各自管理 share」，但這樣一來，整體供應量與兌換比例就會變得很難在多鏈之間維持一致，也會讓結算與風險控管變得更複雜。相較之下，把 share 的狀態統一集中在 ZetaChain 上，讓它專心負責「全局記帳」，反而比較符合目前這個簡化版跨鏈 Vault 的定位，也比較容易在之後往上疊更多邏輯（例如收益分配、策略路由等等）。  
  
之後會找一天對`deposit` 做更完整的測試，以及完成 `withdraw` 的流程筆記
<!-- DAILY_CHECKIN_2025-11-30_END -->

# 2025-11-29
<!-- DAILY_CHECKIN_2025-11-29_START -->




今天繼續深入Messaging範例合約的細節

## Messaging完整流程

昨天只介紹了Messaging範例`Messaging.sol`的主要功能，那所以先來將他們統整起來，變成一個完整且簡單易懂的流程

### 部屬合約

昨天只介紹了Messaging範例`Messaging.sol`的主要功能，那所以先來將他們統整起來，變成一個完整且簡單易懂的流程

那我們先進行部屬合約，依照官方流程，那在這裡官方文件有點問題，他們的範例合約constructor跟繼承`Messaging.sol`的constructor順序不一樣，所以會導致後面的參數被revert

這是範例合約的constructor

![3b874ba2337cfda67acc06d47eb06ac6.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-29-1764410902088-3b874ba2337cfda67acc06d47eb06ac6.png)

而去找繼承`Messaging.sol`會發現範例合約的順序會`ownerAddress` 與 `gatewayAddress`對調

![64397ab8ead0f49e224ef7123fd361b9.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-29-1764410909808-64397ab8ead0f49e224ef7123fd361b9.png)

但解決方法也很簡單，將範例合約與部屬script改成傳入正確順序的參數即可解決

**Base Sepolia**

```
MESSAGING_BASE=$(./commands/index.ts deploy --rpc https://sepolia.base.org --private-key $PRIVATE_KEY | jq -r .contractAddress)
```

**Ethereum Sepolia**

```
MESSAGING_ETHEREUM=$(./commands/index.ts deploy --rpc https://sepolia.drpc.org --private-key $PRIVATE_KEY | jq -r .contractAddress)
```

### 連接合約

下一步是將兩者做雙向連接，也就是透過昨天提過`setConnected()`，這邊官方提供script讓我們方便連接，因為是雙向連接，所以兩條鏈的合約都要記錄對方鏈的合約

**Base Sepolia 紀錄Ethereum Sepolia的Messaging.sol**

```
./commands/index.ts connect \
  --contract $MESSAGING_BASE \
  --target-contract $MESSAGING_ETHEREUM \
  --rpc https://sepolia.base.org \
  --target-chain-id 11155111 \
  --private-key $PRIVATE_KEY
```

**Ethereum Sepolia紀錄Base Sepolia的Messaging.sol**

```
./commands/index.ts connect \
  --contract $MESSAGING_ETHEREUM \
  --target-contract $MESSAGING_BASE \
  --rpc https://sepolia.drpc.org \
  --target-chain-id 84532 \
  --private-key $PRIVATE_KEY
```

### 傳送跨鏈訊息

那接下來我們就可以傳送跨鏈訊息了，一樣用官方script去傳送

```
./commands/index.ts message \
  --rpc https://sepolia.base.org \
  --private-key $PRIVATE_KEY \
  --contract $MESSAGING_BASE \
  --target-contract $MESSAGING_ETHEREUM \
  --types string \
  --values hello \
  --target-token 0x05BA149A7bd6dC1F937fA9046A9e05C05f3b18b0 \
  --amount 0.005
```

那用`query cctx`去追蹤跨鏈交易，我們可以看到有成功傳送跨鏈訊息

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-29-1764411128787-image.png)

### 跨鏈訊息背後邏輯

那這個跨鏈訊息他是怎麼傳過去的呢?

當我們呼叫`sendMessage()`時會去調用目前鏈的Gateway合約`depositAndCall()`，那這`depositAndCall()`**會將夾帶資產再轉給其他地址進行託管**（TSS address或custody address），並發出`DepositedAndCalled`的event

那此時**Zetachain的Observer會監聽這類的事件**，當監聽到時，就會進行投票，如果投票通過就會調用Zetachain上Gateway合約的`depositAndCall()`，而這個`depositAndCall()`會去調用`UniversalContractOnCall()`，而在範例合約裡，他是連接到叫`UniversalRouter.sol`的合約（可以在[這裡](https://github.com/zeta-chain/standard-contracts)看他的source code）

調用`UniversalRouter.solOnCall()`的同時，還會Mint ZRC20到`UniversalRouter.sol`，而在這個`UniversalRouter.sol`會**將訊息及資產做處理（假設Ａ鏈轉到Ｂ鏈，會將Ａ鏈的ZRC20 Swap成B鏈的ZRC20）**，並且調用Zetachain上Gateway合約的`withdrawAndCall()`，將剛剛換到的ZRC20燒毀，並發出`WithdrawnAndCalled`的事件，**準備在目標鏈解鎖ZRC20對應的Native Token或ERC20**

這時候Observer監聽到後，**會進行TSS流程（只有Outbound transactions會需要TSS流程）**，完成流程後TSS signer會在調用目標鏈Gateway的`execute()`或是`executeWithERC20()`(依據資產種類決定)。

`execute()`會去觸發我們在目標鏈部屬範例合約的`Oncall()`（繼承自`Messaging.sol`），**同時將Gateway合約對應的資產轉移到範例合約上**（因為剛剛有燒毀ZRC20所以可以解鎖對應的數量到`Messaging.sol`上）以及一些檢查（驗證是否是連接合約、正確的Router），這時候才會觸發我們的`onMessageReceive()`

那將流程摘要起來的話就是

來源鏈呼叫 `sendMessage()`→ `GatewayEVM.depositAndCall()` → Observer 驗證 → Zetachain `GatewayZEVM.depositAndCall()` → `UniversalRouter.onCall()` → Observer / TSS驗證 → `GatewayZEVM.withdrawAndCall()` → 目標鏈 `GatewayEVM.execute/executeWithERC20()` → `Messaging.onCall()` → 最後進到範例合約實作的 `onMessageReceive()`。

或是可以用圖片去理解

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-29-1764411384570-image.png)

而下面的圖則專注於Token的轉移

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-29-1764411391793-image.png)

### 小結

雖然調用的步驟很簡單，但是背後經過的合約邏輯也是蠻多的，整理起來也是挺花時間的，明天可以實際改看看Router合約看看能做什麼變化，最後如果內容有如果有誤，歡迎指正!
<!-- DAILY_CHECKIN_2025-11-29_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->





昨天研究Swap，今天研究Messaging的範例合約

## Messaging Example

這個Messaging的範例合約，值得注意的是它的用法不是部屬在Zetachain上，而是部屬在你要連接的兩條鏈上，那他的條件是要繼承Zetachain的合`Messaging.sol`並實作裡面的幾個function才能運作

另外Zetachain則負責傳遞你的訊息，概念跟Layer0蠻像的，基本上Messaging的合約很簡單，就是在做訊息的傳遞，並有兩種類型的訊息傳遞，第一種類型是可夾帶Native Token的訊息傳遞，第二種類型是可以夾帶ERC20的訊息傳遞

### Messaging.sol

那前面有提到要成功在兩條鏈互通的條件是要繼承Zetachain的合`Messaging.sol`並實作裡面的幾個function才能運作。

可以先從初始化開始介紹，這裡範例合約初始化沒做什麼，只是把參數轉給 `Messaging.sol`，讓它去初始化內部需要用到的變數（像是 gateway、router 還有 owner 等等）

```
constructor(
    address payable _gateway,
    address owner,
    address _router
) Messaging(_gateway, owner, _router) {}
```

那主要有三個function是我們需要去實作的`onMessageReceiveonMessageRevertonRevert`

**onMessageReceive**

這表示合約收到Message要做的邏輯，當跨鏈訊息送過去目標鏈，最後會將訊息送到這function裡面去做處理，這裡範例合約沒做什麼特別的邏輯，只有emit event而已，但實際上我們能做的事情可以很多，像是把 data decode 成 function selector + 參數，去呼叫另外一個合約的function之類的

```
function onMessageReceive(
    bytes memory data,
    bytes memory sender,
    uint256 amount,
    bytes memory asset
) internal override {
    emit OnMessageReceiveEvent(data);
}
```

**onMessageRevert**

`onMessageRevert` 則是處理**跨鏈執行失敗**的邏輯。這個失敗並不是代表訊息沒送到，而是在執`onMessageReceive`失敗的話就會執行這個邏輯

```
function onMessageRevert(
    bytes memory data,
    bytes memory sender,
    uint256 amount,
    bytes memory asset
) internal override {
    emit OnMessageRevertEvent();
    // Revert from destination chain
}
```

**onRevert**

`onRevert` 則表示訊息還沒送到目標鏈時就失敗的處理邏輯，在Zetachin處理訊息的過程中就失敗了，所以如果有跨鏈轉移資產的操作，可以在這個操作去做返還

```
function onRevert(
    RevertContext calldata context
) external payable override onlyGateway {
    if (context.sender != router) revert Unauthorized();
    emit OnRevertEventEVM();
    // Revert from ZetaChain
}
```

而 `Messaging.sol` 還有其他幾個輔助用的 function，主要是負責**設定對應鏈的合約地址**，以及當 Gateway 把訊息丟進來時的統一入口。

**setConnected**

`setConnected` 用來告訴合約**某一條鏈上對應的 Messaging 合約地址是誰**。

因為同一份 Messaging 會部署在兩條鏈上（例如:Ethereum + BSC），所以需要一個 mapping 去記錄**每個 chainID 對應的合約位址**

```
function setConnected(
    uint256 chainID,
    bytes memory contractAddress
) external onlyOwner {
    connected[chainID] = contractAddress;
}
```

這邊用 `onlyOwner` 保護，避免隨便一個人亂改 cross-chain 的對應關係。而用法是在部屬兩條鏈的合約之後，兩邊都要調用這個合約才可以建立起雙向連結，設定完這個後才可以開始互相傳送跨鏈訊息，否則會直接被Revert

**Oncall**

`onCall` 可以理解成 **Messaging 合約在「目的鏈」收到跨鏈訊息時的統一入口**。這裡就講比較重要的幾個邏輯

```
function onCall(
    MessageContext calldata context,
    bytes calldata message
) external payable onlyGateway returns (bytes memory)
```

那會先`router`的檢查以及檢查是否是透`setConnected`連結的合約，所以如果前面才會說沒設定就會被Revert

```
if (
    context.sender != router ||
    keccak256(sender) != keccak256(connected[sourceChainID])
) revert Unauthorized();
```

那如果這個跨鏈訊息有帶ERC20的話，那也會在這個function將錢轉到這個合約，所以就表示我們在處`onMessageReceive`的邏輯的時候，如果有資產轉移的邏輯時，要注意ERC20在執`onMessageReceive`之前，資產就已經在合約上了

而為什麼這裡只做ERC20的處理呢，因為Native Token，他們不用特別再去轉移，在Gateway合約呼叫這個function時會一起送進來(如果有的話)，這點從function帶`payable`可以判斷出來

```
if (asset.length > 0) {
    address assetAddress = address(uint160(bytes20(asset)));
    IERC20(assetAddress).safeTransferFrom(
        msg.sender,
        address(this),
        amount
    );
}
```

那接下來前置作業完成就是準備呼叫主要的邏`onMessageReceive`，那這邊是會依`isCall`去決定說要執`onMessageReceive`還`onMessageRevert`，那他這樣寫的邏輯，我推測是他會呼叫兩`OnCall`（如`onMessageReceive`失敗的話），而第二次就是`isCall`設定`False`，但這個是推測的哈哈，詳細的還需要再去研究研究

```
if (isCall) {
    onMessageReceive(data, sender, amount, asset);
} else {
    onMessageRevert(data, sender, amount, asset);
}
```

* * *

這邊是如何發送跨鏈訊息的邏輯`Messaging.sol`就沒有這類的邏輯了，要自己去實作，下面的都是Messaging的範例合約內容

### 可夾帶Native Token的訊息傳遞

可以看到`payable`的修飾符，表示再送交易時可以夾帶Native Token或著說`msg.value`也可以

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external payable {
```

### 可夾帶ERC20的訊息傳遞

而這類型的訊息傳遞就沒`payable`了，取而代之是多傳入兩個參數`asset`跟`amount`

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    uint256 amount,
    address asset,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external
```

* * *

那我可以先來看第一種類型`sendMessage`，其實做的事情非常簡單，就是將傳入參數`abi.encode`打包成一串bytes格式，這是為了方便讓參數在合約間傳遞的一個方法，這個message會傳到gateway那邊`depositAndCall`去做進一步處理

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external payable {
    bytes memory message = abi.encode(
        receiver,
        targetToken,
        data,
        gasLimit,
        revertOptions
    );
    gateway.depositAndCall{value: msg.value}(
        router,
        message,
        revertOptions
    );
}
```

`depositAndCall`是怎麼運作的呢，`GatewayEVM.sol`可以找到實作，主要就是做兩件事情

第一件事情，就是將錢轉給Zetachain的合約做託管，而Native Token與ERC20轉的合約對象不一樣，Native Token版本是轉給TSS address（TSS address 是由 ZetaChain 的 Validator 用門檻簽名共同管理的特殊地址）這邊推測應該是做個分類，也許改天可以再深入研究

```
// Native Token版本
(bool deposited,) = tssAddress.call{ value: amount }("");
// ERC20版本
_transferFromToAssetHandler(msg.sender, asset, amount);
```

第二件事情是發送事件，這樣才可以讓 ZetaChain 上負責監聽事件的 **Observer Validator** 偵測到這筆跨鏈呼叫的發生。畢竟在整個跨鏈流程中，ZetaChain 本身不會主動知道你在其他鏈上做了什麼，必須依賴這些 Validator 去抓取事件、驗證事件、並用 TSS 把指令送回 ZetaChain 或送到其他鏈。

```
// Native Token版本
emit DepositedAndCalled(msg.sender, receiver, amount, address(0), payload, revertOptions);
// ERC20版本
emit DepositedAndCalled(msg.sender, receiver, amount, asset, payload, revertOptions);
```

## 小結

今天時間比較沒那麼多，所以先做個Messaging的粗淺研究，明天再做實際測試及更深入的研究及驗證目前推測的一些想法，內容如果有誤，歡迎指正!
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->







昨天研究了基礎架構，那今天研究一下**Universal App**的Swap範例在寫什麼

## Swap

### 核心流程

使用者在其他鏈（例如Ethereum、Bitcoin、BSC 等）把ERC-20或Native token經由Gateway傳入Zetachain，傳入的方式是先在來源鏈的Gateway鎖定資產，並在ZetaChain的Gateway上為該資產鑄造對應的 **ZRC-20**。

Swap 合約本身只處理 ZRC-20：

它先接收某一種 ZRC-20 作為輸入，透過 ZetaChain 上的 DEX（Uniswap V2 Router）將其兌換成另一種目標 ZRC-20。

畫了張圖將流程大致上畫出來了，不過有省略一些細節，像是Gasfee的細節

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764184098763-image.png)

### Oncall

```
function onCall(
        MessageContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
) external override onlyGateway 
```

這是Swap中的核心function，主要處理其他鏈傳來的Swap訊息，用來處理「其他鏈 → ZetaChain」透過 Gateway 傳入的跨鏈 swap 訊息。

可以注意到 `onlyGateway` 修飾器，代表 **只有 ZetaChain 的 Gateway 合約能呼叫這個 function**，確保跨鏈訊息來源是可信的。

且傳入參數分別為

-   `context`：跨鏈訊息的來源資訊（來源鏈、來源地址等 metadata）。
    
-   `zrc20`：此次跨鏈傳入的來源資產在 ZetaChain 上的 ZRC20 版本。
    
-   `amount`：附帶進來的 ZRC20 數量。
    
-   `message`：來源鏈用 `abi.encode` 打包的 swap 參數（目標 token、收款人、是否 withdraw）。
    

基本上這個function可以拆成3個部分來看

```
(address targetToken, bytes memory recipient, bool withdrawFlag) = abi.decode(message, (address, bytes, bool));
```

第一個部分是解析跨鏈傳過來的message，那這個message是依照abi規範打包成的一串bytes，abi詳細的規範可以參考[這裡](https://learnblockchain.cn/docs/solidity/abi-spec.html)，那這裡是用decode去解析`targetTokenrecipientwithdrawFlag`

`targetToken`是目標交換的ZRC token address`recipient`是收款地址（比較特別的是它不是address 型別而是bytes型別，這是為了兼容EVM以外的鏈）`withdrawFlag`則是表示這筆交易Swap完後是留在Zetachain上`false`)還是跨到別的鏈上`true`)

```
(uint256 out, address gasZRC20, uint256 gasFee) = handleGasAndSwap(
	zrc20,
	amount,
	targetToken,
	withdrawFlag
);
```

第二個部分就是調用交換的參數，等等會詳細解析怎麼做，這裡先知道他這個部分執行完後，Swap就完成了

```
withdraw(
	Params({
		target: targetToken,
		to: recipient,
		withdraw: withdrawFlag
	}),
	abi.encodePacked(context.sender),
	gasFee,
	gasZRC20,
	out,
	zrc20
);
```

第三個部分是Withdraw，因為前一個部分Swap完的ZRC20實際上是還留在合約裡面，這一步主要會依`withdrawFlag`的不同而做不同的處理

### handleGasAndSwap

```
function handleGasAndSwap(
        address inputToken,
        uint256 amount,
        address targetToken,
        bool withdraw
) internal returns (uint256, address, uint256)
```

這個function負責處理兩件事情

1\. **如果需要跨鏈 withdraw**，先準備好目標鏈所需的 gas 費用（先計算做預留）

2\. 用剩下的金額進行 token swap（inputToken → targetToken）

而跨鏈 withdraw 的 gas 是 **不能用 ZetaChain 上的 ZETA 支付的**。

每個鏈都有不同的 gas 模式，且名字還蠻酷的用鏈名.鏈名的方式去取名，如下表格

| 目標鏈 | withdraw gas token (ZRC20) |
| --- | --- |
| Ethereum | ETH.ETH |
| Bitcoin | BTC.BTC |
| Polygon | POL.POL |

```
(gasZRC20, gasFee) = IZRC20(targetToken).withdrawGasFee();
uint256 minInput = quoteMinInput(inputToken, targetToken);
if (amount < minInput) {
    revert InsufficientAmount(
        "The input amount is less than the min amount required to cover the withdraw gas fee"
    );
}
```

這裡合約`withdrawGasFee()`查詢目標的ZRC20 Token所屬的鏈他的GasToken是什麼以及Gasfee是多少，並`quoteMinInput`算至少要多少input token才能付得起Gas，付不起就revert

```
if (gasZRC20 == inputToken) {
	swapAmount = amount - gasFee;
} else {
	inputForGas = SwapHelperLib.swapTokensForExactTokens(
		uniswapRouter,
		inputToken,
		gasFee,
		gasZRC20,
		amount
	);
	swapAmount = amount - inputForGas;
}
```

接下來處理Gas的邏輯還有兩種情況

第一種是如果使用者提供`inputToken`本身就是目標鏈需要`gasZRC20`，那會直接扣掉gasFee，剩下的拿去swap。如果不是的話用UniswapV2換出\*\*「剛好等於gasFee的gasZRC20」\*\*，再把剩下的拿去swap。

另外這裡以上的邏輯都`withdrawFlag=true`的情況，如果`false`會直接執行下面的交換，因為就不用支付跨鏈的Gas

```
uint256 out = SwapHelperLib.swapExactTokensForTokens(
	uniswapRouter,
	inputToken,
	swapAmount,
	targetToken,
	0
);
```

這裡做的事情其實很單純，就是呼叫Uniswap V2 Router，用手上剩餘的ZRC20兌換成目標的ZRC20。輸入的數量（swapAmount）是固定的，換到多少就收多少，然後這裡滑點沒有特別設置我推測應該只是方便測試防止失敗，不然這樣使用者體驗會很差，實際環境還是要給使用者有設定滑點的選項。

### withdraw

```
function withdraw(
    Params memory params,
    bytes memory sender,
    uint256 gasFee,
    address gasZRC20,
    uint256 out,
    address inputToken
) internal
```

前面 `handleGasAndSwap` 已經把該付的跨鏈 Gas 計算好、把剩下的 swap 成目標 ZRC20；但這些 token 還是在合約裡面，所以最後一步就是依照 `withdrawFlag` 的設定，決定**要讓 Token 留在 ZetaChain**還是 **跨鏈 withdraw 回使用者在來源鏈的地址**

先講如`withdraw = true`的情況

```
if (gasZRC20 == params.target) {
		if (!IZRC20(gasZRC20).approve(address(gateway), out + gasFee)) {
			revert ApprovalFailed();
		}
	} else {
		if (!IZRC20(gasZRC20).approve(address(gateway), gasFee)) {
			revert ApprovalFailed();
		}
		if (!IZRC20(params.target).approve(address(gateway), out)) {
			revert ApprovalFailed();
		}
	}
}
```

因`withdraw = true`，所以要支付Gas出去，所以這裡`approve`給gateway合約，這裡gateway合約才能跟我們收取手續費

而如果目標鏈的gas token（gasZRC20）剛好就是 swap 出來的目標 token（[params.target](http://params.target)），就一次 approve `out + gasFee`如果不是同一種代幣，就要分兩次 approve：一次給 gasFee、一次給 swap 出來的 out

```
gateway.withdraw(
    abi.encodePacked(params.to),
    out,
    params.target,
    RevertOptions({
        revertAddress: address(this),
        callOnRevert: true,
        abortAddress: address(0),
        revertMessage: abi.encode(sender, inputToken),
        onRevertGasLimit: gasLimit
    })
);
```

接著就調用gateway`withdraw`，去對目標鏈的gateway發起訊息，這裡丟進的參數可以這樣解釋

把「收款人位址（[params.to](http://params.to)）、要發多少（out）、發什麼 token（[params.target](http://params.target)）」，再加上一些 revert 時要怎麼處理的設定，一起丟給 Gateway， 讓 Gateway 去幫我們在目標鏈完成實際的資產轉移。

這裡有個很有趣的設定`RevertOptions`，如果目標鏈那邊Transfer發生什麼問題的話，Gateway 會再 call 回這個 Swap 合約的 `onRevert`，讓合約有機會把錢換回來、再退還給原本的 sender。

最後`withdraw = false`的情況

```
bool success = IWETH9(params.target).transfer(
    address(uint160(bytes20(params.to))),
    out
);
if (!success) {
    revert TransferFailed(
        "Failed to transfer target tokens to the recipient on ZetaChain"
    );
}
```

整個流程就簡單很多，因為不需要跨鏈，也不需要付跨鏈 Gas，合約只需要把 swap 出來的目標 ZRC20 直接轉給收款人就好

### Swap測試實際操作

```
npx zetachain evm deposit-and-call \
  --chain-id 11155111 \
  --amount 0.001 \
  --types address bytes bool \
  --receiver $UNIVERSAL \
  --values $ZRC20_SOL_SOL $RECIPIENT true \
  --private-key $PRIVATE_KEY
```

這裡測試了在測試網從Sepolia的ETH換成Solana devnet的SOL，指令如上

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-27-1764250376756-image.png)

但這邊試了很多次都會被revert，今天剛好聽完workshop，聽他們說是流動性不足的問題，所以失敗是很正常的

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-27-1764250399716-image.png)

## 小結

其實Swap的範例不只在跨鏈而已，在Zetachain上直接當正常的Swap調用也可以，但就沒特別去寫，蠻有趣的是它定義Gasfee的機制，稍微看一下似乎是協議方定義的，但沒有特別去看他是怎麼去安全且正確的定義每條鏈的Gasfee，之後也許可以研究看看
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->











今天研究Zetachain的共識模型以及架構設計

## 基礎架構

基本上，Zetachain是建構在Cosmos的框架上的一條POS鏈，共識層使用 CometBFT，而執行層則採用 Cosmos EVM

而與其他的公鏈比較不一樣的地方在於，其他公鏈通常是專注於自己鏈上的生態並想辦法擴大自己鏈上的生態，而Zetachain則是專注於解決**跨鏈溝通、鏈抽象**這類問題，所以Zetachain的生態實際上不與其他公鏈衝突，而是與他們有著合作的關係

### Hub-and-Spoke Model

Hub-and-Spoke Model是Zetachain如何運作的架構，也就是他如何協調及進行**跨鏈溝通、鏈抽象**的方式

Zetachain是Hub，而其他的鏈全部都是Spoke，那不論今天哪條鏈要對哪條鏈進行訊息的傳遞，那這個訊息統一會經過Hub

而用最簡易的圖理解大概會向下面這樣，任何兩條外部鏈之間的通信都必須通過 ZetaChain 中轉。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091288977-image.png)

### 共識層

前面提到共識是用CometBFT的技術，那稍微研究了下CometBFT是怎麼進行共識的，在CometBFT裡，只要有超過2/3節點還是正常運行且非惡意，那麼網路都可以正常運作，這同時也是CometBFT名字中的BFT名字來源，全名是Byzantine fault tolerance (BFT)

每個 Height 都會先從 Validators 中選出一位 Proposer，負責該區塊的出塊。當 Proposer 出塊後，會進入第一階段 **pre-vote**。這時候需要等待至少 2/3 的 Validators 對區塊進行 **pre-vote**；如果通過，就會進入下一階段 **pre-commit**。

在 pre-commit 階段，同樣需要至少 2/3 的 Validators 對區塊進行 **pre-commit**。當這個條件達成後，該區塊就會被正式 **Commit**，代表這個區塊已經進入 **finalized** 的狀態。

而跟Bitcoin一樣，每個Height只會有一個區塊，所以每當區塊被產出就會進入新的Height，並繼續選擇新的的Proposer

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091040346-image.png)

而前面的流程只是假設一切狀況順利的話，但實際網路不一定這麼順利，像是選到的Proposer如果沒有出塊或是出有問題的區塊的話，CometBFT會怎麼處理呢?

基本上只要在**pre-vote**或是**pre-commit**，其他Validator沒有收到區塊或是區塊是有問題那其實會進到下一個round，重新選新的Proposal，直到有區塊被正式Commit，下面是假設出問題的流程大概會長樣

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091050471-image.png)

而以上是CometBFT最粗淺的流程，其實還有很多細節沒有去研究，像是他每次選擇Validator的演算法或是他如何快速傳播區塊的方法

而ZetaChain 的 Validators 分成兩種，這是比較特別的地方：

**Core Validators**

指的是剛才介紹的CometBFT裡面的Validator，他負責

-   執行 CometBFT 共識
    
-   出塊、驗證區塊是否合法
    
-   參與 Pre-vote / Pre-commit / Commit
    

**Observer-Signer Validators**

他比較像是Oracle的定位，而他負責：

-   監控外部鏈的事件是否真實發生
    
-   對有效事件進行投票
    
-   達成門檻後，使用 **TSS（Threshold Signature Scheme）** 共同簽 outbound 交易
    

所以我們也可以這樣去理解：

**Core Validators（區塊合法性） → Observer-Signer Validators（跨鏈合法性**）

## Gateway

Gateway是負責與連結Zetachain的合約，基本上每條鏈都會有Gateway的存在，但會隨著每條鏈的底層機制不同而有不同的實作，像是Solana是Gateway Program、EVM是Gateway smart contract，但本質上他們要做的事都是一樣的，就是要讓我們可以透過Gateway合約傳送跨鏈訊息  
  
另外Zetachain上也有Gateway去將外來鏈的call連接Zetachain上的合約，或是從Zetachain將訊息傳到其他鏈

那我們可以用前面**Hub-and-Spoke Model**的圖去加上Gateway，可以更了解它的定位在哪裡

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764151648727-image.png)

## Universal App

Universal App 則表示在Zetachain上部屬合約建構一個連接各種鏈的Dapp，可以接受來自任意鏈的合約呼叫或是訊息，也就是說User今天從哪條鏈都可以與Universal App進行互動，大大增強了UX

那我們可以再次修改前面的圖，加上Universal App的概念後，就可以知道整個Zetachain大概是在跨什麼鏈了

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764151626133-image.png)

## 一些額外觀察

稍微看過他的基礎架構發現他的Hub-and-Spoke Model與LayerZero的OVault有點像，只是OVault是自己選一條鏈當Hub，而Zetachain本身就是Hub，也許改天可以研究他們之間的差異及相似之處，或是看看市面上還有什麼也是用這種架構

若文中有任何錯誤或誤解之處，歡迎不吝指正，一起交流討論。
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->















第一天嘗試在本地鏈部屬，今天實際部屬看看測試鏈以及熟悉Zetachain的一些其他工具

## Faucet

那畢竟Zetachain是一條Layer1網路，所以在上面做操作還是需要一點Gas fee去作為節點的報酬，那這裡是用官方提供的[Faucet](https://zetachain.faucetme.pro/)去領

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075520410-image.png)

## RPC&Network

那領完了Token，但錢包沒有特別設定基本上是看不到的，所以可以到[Network Details](https://www.zetachain.com/docs/reference/network/details)去看詳細的網路設置，將網路的資訊加進來後，錢包才可以透過RPC去讀取到我們剛剛領取的ZETA，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075616679-image.png)

而[RPC/API endpoints](https://www.zetachain.com/docs/reference/network/api#public-endpoints)裡有更多公共的RPC可以用，或是也可以用一些第三方服務建立私人的，像是Alchemy、dRPC等等服務

## Depoly on testnet

那跟部屬在本地鏈一樣，都要有個人去支付Gasfee部屬合約，所以這裡我們改用剛剛領取ZETA作為Gasfee，並填入錢包的私鑰

```
PRIVATE_KEY=<Your private key>
```

並用官方提供指令在Zetachain的測試網部屬合約

```
UNIVERSAL=$(forge create Universal \

  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public \

  --private-key $PRIVATE_KEY \

  --broadcast \

  --json | jq -r .deployedTo)
```

部屬完後`echo`檢查合約地址

```
echo $UNIVERSAL
```

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075680329-image.png)

我們可以用官方提供的[explorer](https://testnet.zetascan.com/address/0x93D68B4C0793fF1D4D11f049F8682a1e256aC59d?tab=index)去查看剛剛部屬的合約，可以看到合約有成功部屬

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075689657-image.png)

## Call Universal Contracts

那下一步就是測試看看從其他的測試網傳送跨鏈訊息到剛剛部屬的合約，官方是從Base Sepolia去call，那這裡試著從Sepolia去call，Seploia的chainId是11155111，而我們要call Universal Contracts的話就要先找到gateway contract

可以用Zetachain的CLI直接查Seploia的gateway contract

```
zetachain query contracts show --type gateway --chain-id 11155111
```

那在將剛剛查到的Gateway contract地址紀錄起來

```
GATEWAY_EVM=0x0c487a766110c85d301D96E33579C5B317Fa4995
```

最後就可以`zetachain evm call`去傳送跨鏈訊息到Universal Contract

```
npx zetachain evm call \

  --chain-id 11155111 \

  --receiver $UNIVERSAL \

  --private-key $PRIVATE_KEY \

  --types string \

  --values hello
```

成功之後會有hash值，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075735295-image.png)

那我們還可以用Zetachain的CLI去追蹤我們的跨鏈訊息

```
npx zetachain query cctx -h 0x7d7258c5f20354572e9e92a300cb3078daa563f75cbb612366430c0299ac7e4e
```

下面的訊息就顯示了兩條鏈分別的交易Hash、誰發送交易、誰接收Message、以及傳送的Message等等詳細訊息

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075755320-image.png)

Qwen API

用第一天的API KEY去發送Request，用法參考[API References](https://modelstudio.console.alibabacloud.com/?tab=api&accounttraceid=24b70361d9e8495eabc5a296e2810dffbibj#/api)

接著用Postman送Post的request就行

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764076777112-image.png)
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->


















# **Day1 - Envrionment**

Zetachain

Zetachain是條Layer1的區塊鏈，有自己的共識機制，目標主要是做一條通用(Universal)區塊鏈，可以連接、讀寫所有鏈

要開始使用Zetachain，要先裝CLI

```
npm install -g zetachain
```

安裝完成後可以用下面指令去試用，並查詢zetachain支援的鏈

```
zetachain query chains list
```

接下來如果要進行開發，官方建議在本地用他們的工具\[Localnet\]([https://www.zetachain.com/docs/reference/localnet/)進行開發，可以輕鬆測試跨鏈邏輯，下面指令可以一鍵啟動](https://www.zetachain.com/docs/reference/localnet/\)%E9%80%B2%E8%A1%8C%E9%96%8B%E7%99%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BC%95%E9%AC%86%E6%B8%AC%E8%A9%A6%E8%B7%A8%E9%8F%88%E9%82%8F%E8%BC%AF%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%8C%87%E4%BB%A4%E5%8F%AF%E4%BB%A5%E4%B8%80%E9%8D%B5%E5%95%9F%E5%8B%95)

```
npx zetachain@latest localnet start
```

成功後可看到各條鏈的相關合約地址，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763968437688-image.png)

## 初始化專案

如果要啟動Zetachain的項目，可以用下面的指令

```
npx zetachain@latest new --project hello

cd hello

yarn

forge soldeer update
```

那接下來可以開始嘗試在本地鏈部屬合約，那部屬合約需要一個部屬者，這裡用Anvil事先提供好已經有Gasfee的地址

```
PRIVATE_KEY=$(jq -r ‘.private_keys[0]’ ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

那設定好部屬者的PRIVATE\_KEY就可以部屬合約在Zetachain了

```
UNIVERSAL=$(forge create Universal \

--rpc-url http://localhost:8545 \

--private-key $PRIVATE_KEY \

--evm-version paris \

--broadcast \

--json | jq -r .deployedTo) && echo $UNIVERSAL
```

那我們應該如何呼叫這個在Zetachain上的合約呢，我們可以任意選一條鏈，並將他的Gateway contract的地址找出來，那我們接下來要做的就是與這個Gateway contract互動，請他幫我們把訊息打到我們剛剛在Zetachain上部屬的合約

下面的指令可以直接幫我們抓Ethereum Sepolia的Gateway contract

```
GATEWAY_EVM=$(jq -r ‘.[“11155112”].contracts[] | select(.contractType == “gateway”) | .address’ ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

接下來用ZetaChain CLI內建call Gateway contract傳遞Hello到我們部屬的合約

```
npx zetachain evm call \

--rpc http://localhost:8545 \

--gateway $GATEWAY_EVM \

--receiver $UNIVERSAL \

--private-key $PRIVATE_KEY \

--types string \

--values hello
```

## Qwen

查了一下Qwen的背景，是由alibabacloud推出的大語言模型，但是他完全開源，所以可以調用官方的API去使用，或是本地自己部屬運行也可以

登入之後就可以創建API Key

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763968585600-image.png)

###   
微信群  
  

![](image.jpg)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763999194679-image.png)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
