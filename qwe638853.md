---
timezone: UTC+8
---

# 林威立

**GitHub ID:** qwe638853

**Telegram:** @qwe638853

## Self-introduction

認識一些Zetachain

## Notes

<!-- Content_START -->
# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->
昨天研究Swap，今天研究Messaging的範例合約

## Messaging Example

這個Messaging的範例合約，值得注意的是它的用法不是部屬在Zetachain上，而是部屬在你要連接的兩條鏈上，那他的條件是要繼承Zetachain的合`Messaging.sol`並實作裡面的幾個function才能運作

另外Zetachain則負責傳遞你的訊息，概念跟Layer0蠻像的，基本上Messaging的合約很簡單，就是在做訊息的傳遞，並有兩種類型的訊息傳遞，第一種類型是可夾帶Native Token的訊息傳遞，第二種類型是可以夾帶ERC20的訊息傳遞

### Messaging.sol

那前面有提到要成功在兩條鏈互通的條件是要繼承Zetachain的合`Messaging.sol`並實作裡面的幾個function才能運作。

可以先從初始化開始介紹，這裡範例合約初始化沒做什麼，只是把參數轉給 `Messaging.sol`，讓它去初始化內部需要用到的變數（像是 gateway、router 還有 owner 等等）

```
constructor(
    address payable _gateway,
    address owner,
    address _router
) Messaging(_gateway, owner, _router) {}
```

那主要有三個function是我們需要去實作的`onMessageReceiveonMessageRevertonRevert`

**onMessageReceive**

這表示合約收到Message要做的邏輯，當跨鏈訊息送過去目標鏈，最後會將訊息送到這function裡面去做處理，這裡範例合約沒做什麼特別的邏輯，只有emit event而已，但實際上我們能做的事情可以很多，像是把 data decode 成 function selector + 參數，去呼叫另外一個合約的function之類的

```
function onMessageReceive(
    bytes memory data,
    bytes memory sender,
    uint256 amount,
    bytes memory asset
) internal override {
    emit OnMessageReceiveEvent(data);
}
```

**onMessageRevert**

`onMessageRevert` 則是處理**跨鏈執行失敗**的邏輯。這個失敗並不是代表訊息沒送到，而是在執`onMessageReceive`失敗的話就會執行這個邏輯

```
function onMessageRevert(
    bytes memory data,
    bytes memory sender,
    uint256 amount,
    bytes memory asset
) internal override {
    emit OnMessageRevertEvent();
    // Revert from destination chain
}
```

**onRevert**

`onRevert` 則表示訊息還沒送到目標鏈時就失敗的處理邏輯，在Zetachin處理訊息的過程中就失敗了，所以如果有跨鏈轉移資產的操作，可以在這個操作去做返還

```
function onRevert(
    RevertContext calldata context
) external payable override onlyGateway {
    if (context.sender != router) revert Unauthorized();
    emit OnRevertEventEVM();
    // Revert from ZetaChain
}
```

而 `Messaging.sol` 還有其他幾個輔助用的 function，主要是負責**設定對應鏈的合約地址**，以及當 Gateway 把訊息丟進來時的統一入口。

**setConnected**

`setConnected` 用來告訴合約**某一條鏈上對應的 Messaging 合約地址是誰**。

因為同一份 Messaging 會部署在兩條鏈上（例如:Ethereum + BSC），所以需要一個 mapping 去記錄**每個 chainID 對應的合約位址**

```
function setConnected(
    uint256 chainID,
    bytes memory contractAddress
) external onlyOwner {
    connected[chainID] = contractAddress;
}
```

這邊用 `onlyOwner` 保護，避免隨便一個人亂改 cross-chain 的對應關係。而用法是在部屬兩條鏈的合約之後，兩邊都要調用這個合約才可以建立起雙向連結，設定完這個後才可以開始互相傳送跨鏈訊息，否則會直接被Revert

**Oncall**

`onCall` 可以理解成 **Messaging 合約在「目的鏈」收到跨鏈訊息時的統一入口**。這裡就講比較重要的幾個邏輯

```
function onCall(
    MessageContext calldata context,
    bytes calldata message
) external payable onlyGateway returns (bytes memory)
```

那會先`router`的檢查以及檢查是否是透`setConnected`連結的合約，所以如果前面才會說沒設定就會被Revert

```
if (
    context.sender != router ||
    keccak256(sender) != keccak256(connected[sourceChainID])
) revert Unauthorized();
```

那如果這個跨鏈訊息有帶ERC20的話，那也會在這個function將錢轉到這個合約，所以就表示我們在處`onMessageReceive`的邏輯的時候，如果有資產轉移的邏輯時，要注意ERC20在執`onMessageReceive`之前，資產就已經在合約上了

而為什麼這裡只做ERC20的處理呢，因為Native Token，他們不用特別再去轉移，在Gateway合約呼叫這個function時會一起送進來(如果有的話)，這點從function帶`payable`可以判斷出來

```
if (asset.length > 0) {
    address assetAddress = address(uint160(bytes20(asset)));
    IERC20(assetAddress).safeTransferFrom(
        msg.sender,
        address(this),
        amount
    );
}
```

那接下來前置作業完成就是準備呼叫主要的邏`onMessageReceive`，那這邊是會依`isCall`去決定說要執`onMessageReceive`還`onMessageRevert`，那他這樣寫的邏輯，我推測是他會呼叫兩`OnCall`（如`onMessageReceive`失敗的話），而第二次就是`isCall`設定`False`，但這個是推測的哈哈，詳細的還需要再去研究研究

```
if (isCall) {
    onMessageReceive(data, sender, amount, asset);
} else {
    onMessageRevert(data, sender, amount, asset);
}
```

* * *

這邊是如何發送跨鏈訊息的邏輯`Messaging.sol`就沒有這類的邏輯了，要自己去實作，下面的都是Messaging的範例合約內容

### 可夾帶Native Token的訊息傳遞

可以看到`payable`的修飾符，表示再送交易時可以夾帶Native Token或著說`msg.value`也可以

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external payable {
```

### 可夾帶ERC20的訊息傳遞

而這類型的訊息傳遞就沒`payable`了，取而代之是多傳入兩個參數`asset`跟`amount`

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    uint256 amount,
    address asset,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external
```

* * *

那我可以先來看第一種類型`sendMessage`，其實做的事情非常簡單，就是將傳入參數`abi.encode`打包成一串bytes格式，這是為了方便讓參數在合約間傳遞的一個方法，這個message會傳到gateway那邊`depositAndCall`去做進一步處理

```
function sendMessage(
    bytes memory receiver,
    address targetToken,
    bytes memory data,
    uint256 gasLimit,
    RevertOptions memory revertOptions
) external payable {
    bytes memory message = abi.encode(
        receiver,
        targetToken,
        data,
        gasLimit,
        revertOptions
    );
    gateway.depositAndCall{value: msg.value}(
        router,
        message,
        revertOptions
    );
}
```

`depositAndCall`是怎麼運作的呢，`GatewayEVM.sol`可以找到實作，主要就是做兩件事情

第一件事情，就是將錢轉給Zetachain的合約做託管，而Native Token與ERC20轉的合約對象不一樣，Native Token版本是轉給TSS address（TSS address 是由 ZetaChain 的 Validator 用門檻簽名共同管理的特殊地址）這邊推測應該是做個分類，也許改天可以再深入研究

```
// Native Token版本
(bool deposited,) = tssAddress.call{ value: amount }("");
// ERC20版本
_transferFromToAssetHandler(msg.sender, asset, amount);
```

第二件事情是發送事件，這樣才可以讓 ZetaChain 上負責監聽事件的 **Observer Validator** 偵測到這筆跨鏈呼叫的發生。畢竟在整個跨鏈流程中，ZetaChain 本身不會主動知道你在其他鏈上做了什麼，必須依賴這些 Validator 去抓取事件、驗證事件、並用 TSS 把指令送回 ZetaChain 或送到其他鏈。

```
// Native Token版本
emit DepositedAndCalled(msg.sender, receiver, amount, address(0), payload, revertOptions);
// ERC20版本
emit DepositedAndCalled(msg.sender, receiver, amount, asset, payload, revertOptions);
```

## 小結

今天時間比較沒那麼多，所以先做個Messaging的粗淺研究，明天再做實際測試及更深入的研究及驗證目前推測的一些想法，內容如果有誤，歡迎指正!
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->


昨天研究了基礎架構，那今天研究一下**Universal App**的Swap範例在寫什麼

## Swap

### 核心流程

使用者在其他鏈（例如Ethereum、Bitcoin、BSC 等）把ERC-20或Native token經由Gateway傳入Zetachain，傳入的方式是先在來源鏈的Gateway鎖定資產，並在ZetaChain的Gateway上為該資產鑄造對應的 **ZRC-20**。

Swap 合約本身只處理 ZRC-20：

它先接收某一種 ZRC-20 作為輸入，透過 ZetaChain 上的 DEX（Uniswap V2 Router）將其兌換成另一種目標 ZRC-20。

畫了張圖將流程大致上畫出來了，不過有省略一些細節，像是Gasfee的細節

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764184098763-image.png)

### Oncall

```
function onCall(
        MessageContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
) external override onlyGateway 
```

這是Swap中的核心function，主要處理其他鏈傳來的Swap訊息，用來處理「其他鏈 → ZetaChain」透過 Gateway 傳入的跨鏈 swap 訊息。

可以注意到 `onlyGateway` 修飾器，代表 **只有 ZetaChain 的 Gateway 合約能呼叫這個 function**，確保跨鏈訊息來源是可信的。

且傳入參數分別為

-   `context`：跨鏈訊息的來源資訊（來源鏈、來源地址等 metadata）。
    
-   `zrc20`：此次跨鏈傳入的來源資產在 ZetaChain 上的 ZRC20 版本。
    
-   `amount`：附帶進來的 ZRC20 數量。
    
-   `message`：來源鏈用 `abi.encode` 打包的 swap 參數（目標 token、收款人、是否 withdraw）。
    

基本上這個function可以拆成3個部分來看

```
(address targetToken, bytes memory recipient, bool withdrawFlag) = abi.decode(message, (address, bytes, bool));
```

第一個部分是解析跨鏈傳過來的message，那這個message是依照abi規範打包成的一串bytes，abi詳細的規範可以參考[這裡](https://learnblockchain.cn/docs/solidity/abi-spec.html)，那這裡是用decode去解析`targetTokenrecipientwithdrawFlag`

`targetToken`是目標交換的ZRC token address`recipient`是收款地址（比較特別的是它不是address 型別而是bytes型別，這是為了兼容EVM以外的鏈）`withdrawFlag`則是表示這筆交易Swap完後是留在Zetachain上`false`)還是跨到別的鏈上`true`)

```
(uint256 out, address gasZRC20, uint256 gasFee) = handleGasAndSwap(
	zrc20,
	amount,
	targetToken,
	withdrawFlag
);
```

第二個部分就是調用交換的參數，等等會詳細解析怎麼做，這裡先知道他這個部分執行完後，Swap就完成了

```
withdraw(
	Params({
		target: targetToken,
		to: recipient,
		withdraw: withdrawFlag
	}),
	abi.encodePacked(context.sender),
	gasFee,
	gasZRC20,
	out,
	zrc20
);
```

第三個部分是Withdraw，因為前一個部分Swap完的ZRC20實際上是還留在合約裡面，這一步主要會依`withdrawFlag`的不同而做不同的處理

### handleGasAndSwap

```
function handleGasAndSwap(
        address inputToken,
        uint256 amount,
        address targetToken,
        bool withdraw
) internal returns (uint256, address, uint256)
```

這個function負責處理兩件事情

1\. **如果需要跨鏈 withdraw**，先準備好目標鏈所需的 gas 費用（先計算做預留）

2\. 用剩下的金額進行 token swap（inputToken → targetToken）

而跨鏈 withdraw 的 gas 是 **不能用 ZetaChain 上的 ZETA 支付的**。

每個鏈都有不同的 gas 模式，且名字還蠻酷的用鏈名.鏈名的方式去取名，如下表格

| 目標鏈 | withdraw gas token (ZRC20) |
| --- | --- |
| Ethereum | ETH.ETH |
| Bitcoin | BTC.BTC |
| Polygon | POL.POL |

```
(gasZRC20, gasFee) = IZRC20(targetToken).withdrawGasFee();
uint256 minInput = quoteMinInput(inputToken, targetToken);
if (amount < minInput) {
    revert InsufficientAmount(
        "The input amount is less than the min amount required to cover the withdraw gas fee"
    );
}
```

這裡合約`withdrawGasFee()`查詢目標的ZRC20 Token所屬的鏈他的GasToken是什麼以及Gasfee是多少，並`quoteMinInput`算至少要多少input token才能付得起Gas，付不起就revert

```
if (gasZRC20 == inputToken) {
	swapAmount = amount - gasFee;
} else {
	inputForGas = SwapHelperLib.swapTokensForExactTokens(
		uniswapRouter,
		inputToken,
		gasFee,
		gasZRC20,
		amount
	);
	swapAmount = amount - inputForGas;
}
```

接下來處理Gas的邏輯還有兩種情況

第一種是如果使用者提供`inputToken`本身就是目標鏈需要`gasZRC20`，那會直接扣掉gasFee，剩下的拿去swap。如果不是的話用UniswapV2換出\*\*「剛好等於gasFee的gasZRC20」\*\*，再把剩下的拿去swap。

另外這裡以上的邏輯都`withdrawFlag=true`的情況，如果`false`會直接執行下面的交換，因為就不用支付跨鏈的Gas

```
uint256 out = SwapHelperLib.swapExactTokensForTokens(
	uniswapRouter,
	inputToken,
	swapAmount,
	targetToken,
	0
);
```

這裡做的事情其實很單純，就是呼叫Uniswap V2 Router，用手上剩餘的ZRC20兌換成目標的ZRC20。輸入的數量（swapAmount）是固定的，換到多少就收多少，然後這裡滑點沒有特別設置我推測應該只是方便測試防止失敗，不然這樣使用者體驗會很差，實際環境還是要給使用者有設定滑點的選項。

### withdraw

```
function withdraw(
    Params memory params,
    bytes memory sender,
    uint256 gasFee,
    address gasZRC20,
    uint256 out,
    address inputToken
) internal
```

前面 `handleGasAndSwap` 已經把該付的跨鏈 Gas 計算好、把剩下的 swap 成目標 ZRC20；但這些 token 還是在合約裡面，所以最後一步就是依照 `withdrawFlag` 的設定，決定**要讓 Token 留在 ZetaChain**還是 **跨鏈 withdraw 回使用者在來源鏈的地址**

先講如`withdraw = true`的情況

```
if (gasZRC20 == params.target) {
		if (!IZRC20(gasZRC20).approve(address(gateway), out + gasFee)) {
			revert ApprovalFailed();
		}
	} else {
		if (!IZRC20(gasZRC20).approve(address(gateway), gasFee)) {
			revert ApprovalFailed();
		}
		if (!IZRC20(params.target).approve(address(gateway), out)) {
			revert ApprovalFailed();
		}
	}
}
```

因`withdraw = true`，所以要支付Gas出去，所以這裡`approve`給gateway合約，這裡gateway合約才能跟我們收取手續費

而如果目標鏈的gas token（gasZRC20）剛好就是 swap 出來的目標 token（[params.target](http://params.target)），就一次 approve `out + gasFee`如果不是同一種代幣，就要分兩次 approve：一次給 gasFee、一次給 swap 出來的 out

```
gateway.withdraw(
    abi.encodePacked(params.to),
    out,
    params.target,
    RevertOptions({
        revertAddress: address(this),
        callOnRevert: true,
        abortAddress: address(0),
        revertMessage: abi.encode(sender, inputToken),
        onRevertGasLimit: gasLimit
    })
);
```

接著就調用gateway`withdraw`，去對目標鏈的gateway發起訊息，這裡丟進的參數可以這樣解釋

把「收款人位址（[params.to](http://params.to)）、要發多少（out）、發什麼 token（[params.target](http://params.target)）」，再加上一些 revert 時要怎麼處理的設定，一起丟給 Gateway， 讓 Gateway 去幫我們在目標鏈完成實際的資產轉移。

這裡有個很有趣的設定`RevertOptions`，如果目標鏈那邊Transfer發生什麼問題的話，Gateway 會再 call 回這個 Swap 合約的 `onRevert`，讓合約有機會把錢換回來、再退還給原本的 sender。

最後`withdraw = false`的情況

```
bool success = IWETH9(params.target).transfer(
    address(uint160(bytes20(params.to))),
    out
);
if (!success) {
    revert TransferFailed(
        "Failed to transfer target tokens to the recipient on ZetaChain"
    );
}
```

整個流程就簡單很多，因為不需要跨鏈，也不需要付跨鏈 Gas，合約只需要把 swap 出來的目標 ZRC20 直接轉給收款人就好

### Swap測試實際操作

```
npx zetachain evm deposit-and-call \
  --chain-id 11155111 \
  --amount 0.001 \
  --types address bytes bool \
  --receiver $UNIVERSAL \
  --values $ZRC20_SOL_SOL $RECIPIENT true \
  --private-key $PRIVATE_KEY
```

這裡測試了在測試網從Sepolia的ETH換成Solana devnet的SOL，指令如上

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-27-1764250376756-image.png)

但這邊試了很多次都會被revert，今天剛好聽完workshop，聽他們說是流動性不足的問題，所以失敗是很正常的

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-27-1764250399716-image.png)

## 小結

其實Swap的範例不只在跨鏈而已，在Zetachain上直接當正常的Swap調用也可以，但就沒特別去寫，蠻有趣的是它定義Gasfee的機制，稍微看一下似乎是協議方定義的，但沒有特別去看他是怎麼去安全且正確的定義每條鏈的Gasfee，之後也許可以研究看看
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->






今天研究Zetachain的共識模型以及架構設計

## 基礎架構

基本上，Zetachain是建構在Cosmos的框架上的一條POS鏈，共識層使用 CometBFT，而執行層則採用 Cosmos EVM

而與其他的公鏈比較不一樣的地方在於，其他公鏈通常是專注於自己鏈上的生態並想辦法擴大自己鏈上的生態，而Zetachain則是專注於解決**跨鏈溝通、鏈抽象**這類問題，所以Zetachain的生態實際上不與其他公鏈衝突，而是與他們有著合作的關係

### Hub-and-Spoke Model

Hub-and-Spoke Model是Zetachain如何運作的架構，也就是他如何協調及進行**跨鏈溝通、鏈抽象**的方式

Zetachain是Hub，而其他的鏈全部都是Spoke，那不論今天哪條鏈要對哪條鏈進行訊息的傳遞，那這個訊息統一會經過Hub

而用最簡易的圖理解大概會向下面這樣，任何兩條外部鏈之間的通信都必須通過 ZetaChain 中轉。

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091288977-image.png)

### 共識層

前面提到共識是用CometBFT的技術，那稍微研究了下CometBFT是怎麼進行共識的，在CometBFT裡，只要有超過2/3節點還是正常運行且非惡意，那麼網路都可以正常運作，這同時也是CometBFT名字中的BFT名字來源，全名是Byzantine fault tolerance (BFT)

每個 Height 都會先從 Validators 中選出一位 Proposer，負責該區塊的出塊。當 Proposer 出塊後，會進入第一階段 **pre-vote**。這時候需要等待至少 2/3 的 Validators 對區塊進行 **pre-vote**；如果通過，就會進入下一階段 **pre-commit**。

在 pre-commit 階段，同樣需要至少 2/3 的 Validators 對區塊進行 **pre-commit**。當這個條件達成後，該區塊就會被正式 **Commit**，代表這個區塊已經進入 **finalized** 的狀態。

而跟Bitcoin一樣，每個Height只會有一個區塊，所以每當區塊被產出就會進入新的Height，並繼續選擇新的的Proposer

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091040346-image.png)

而前面的流程只是假設一切狀況順利的話，但實際網路不一定這麼順利，像是選到的Proposer如果沒有出塊或是出有問題的區塊的話，CometBFT會怎麼處理呢?

基本上只要在**pre-vote**或是**pre-commit**，其他Validator沒有收到區塊或是區塊是有問題那其實會進到下一個round，重新選新的Proposal，直到有區塊被正式Commit，下面是假設出問題的流程大概會長樣

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764091050471-image.png)

而以上是CometBFT最粗淺的流程，其實還有很多細節沒有去研究，像是他每次選擇Validator的演算法或是他如何快速傳播區塊的方法

而ZetaChain 的 Validators 分成兩種，這是比較特別的地方：

**Core Validators**

指的是剛才介紹的CometBFT裡面的Validator，他負責

-   執行 CometBFT 共識
    
-   出塊、驗證區塊是否合法
    
-   參與 Pre-vote / Pre-commit / Commit
    

**Observer-Signer Validators**

他比較像是Oracle的定位，而他負責：

-   監控外部鏈的事件是否真實發生
    
-   對有效事件進行投票
    
-   達成門檻後，使用 **TSS（Threshold Signature Scheme）** 共同簽 outbound 交易
    

所以我們也可以這樣去理解：

**Core Validators（區塊合法性） → Observer-Signer Validators（跨鏈合法性**）

## Gateway

Gateway是負責與連結Zetachain的合約，基本上每條鏈都會有Gateway的存在，但會隨著每條鏈的底層機制不同而有不同的實作，像是Solana是Gateway Program、EVM是Gateway smart contract，但本質上他們要做的事都是一樣的，就是要讓我們可以透過Gateway合約傳送跨鏈訊息  
  
另外Zetachain上也有Gateway去將外來鏈的call連接Zetachain上的合約，或是從Zetachain將訊息傳到其他鏈

那我們可以用前面**Hub-and-Spoke Model**的圖去加上Gateway，可以更了解它的定位在哪裡

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764151648727-image.png)

## Universal App

Universal App 則表示在Zetachain上部屬合約建構一個連接各種鏈的Dapp，可以接受來自任意鏈的合約呼叫或是訊息，也就是說User今天從哪條鏈都可以與Universal App進行互動，大大增強了UX

那我們可以再次修改前面的圖，加上Universal App的概念後，就可以知道整個Zetachain大概是在跨什麼鏈了

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-26-1764151626133-image.png)

## 一些額外觀察

稍微看過他的基礎架構發現他的Hub-and-Spoke Model與LayerZero的OVault有點像，只是OVault是自己選一條鏈當Hub，而Zetachain本身就是Hub，也許改天可以研究他們之間的差異及相似之處，或是看看市面上還有什麼也是用這種架構

若文中有任何錯誤或誤解之處，歡迎不吝指正，一起交流討論。
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->










第一天嘗試在本地鏈部屬，今天實際部屬看看測試鏈以及熟悉Zetachain的一些其他工具

## Faucet

那畢竟Zetachain是一條Layer1網路，所以在上面做操作還是需要一點Gas fee去作為節點的報酬，那這裡是用官方提供的[Faucet](https://zetachain.faucetme.pro/)去領

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075520410-image.png)

## RPC&Network

那領完了Token，但錢包沒有特別設定基本上是看不到的，所以可以到[Network Details](https://www.zetachain.com/docs/reference/network/details)去看詳細的網路設置，將網路的資訊加進來後，錢包才可以透過RPC去讀取到我們剛剛領取的ZETA，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075616679-image.png)

而[RPC/API endpoints](https://www.zetachain.com/docs/reference/network/api#public-endpoints)裡有更多公共的RPC可以用，或是也可以用一些第三方服務建立私人的，像是Alchemy、dRPC等等服務

## Depoly on testnet

那跟部屬在本地鏈一樣，都要有個人去支付Gasfee部屬合約，所以這裡我們改用剛剛領取ZETA作為Gasfee，並填入錢包的私鑰

```
PRIVATE_KEY=<Your private key>
```

並用官方提供指令在Zetachain的測試網部屬合約

```
UNIVERSAL=$(forge create Universal \

  --rpc-url https://zetachain-athens-evm.blockpi.network/v1/rpc/public \

  --private-key $PRIVATE_KEY \

  --broadcast \

  --json | jq -r .deployedTo)
```

部屬完後`echo`檢查合約地址

```
echo $UNIVERSAL
```

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075680329-image.png)

我們可以用官方提供的[explorer](https://testnet.zetascan.com/address/0x93D68B4C0793fF1D4D11f049F8682a1e256aC59d?tab=index)去查看剛剛部屬的合約，可以看到合約有成功部屬

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075689657-image.png)

## Call Universal Contracts

那下一步就是測試看看從其他的測試網傳送跨鏈訊息到剛剛部屬的合約，官方是從Base Sepolia去call，那這裡試著從Sepolia去call，Seploia的chainId是11155111，而我們要call Universal Contracts的話就要先找到gateway contract

可以用Zetachain的CLI直接查Seploia的gateway contract

```
zetachain query contracts show --type gateway --chain-id 11155111
```

那在將剛剛查到的Gateway contract地址紀錄起來

```
GATEWAY_EVM=0x0c487a766110c85d301D96E33579C5B317Fa4995
```

最後就可以`zetachain evm call`去傳送跨鏈訊息到Universal Contract

```
npx zetachain evm call \

  --chain-id 11155111 \

  --receiver $UNIVERSAL \

  --private-key $PRIVATE_KEY \

  --types string \

  --values hello
```

成功之後會有hash值，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075735295-image.png)

那我們還可以用Zetachain的CLI去追蹤我們的跨鏈訊息

```
npx zetachain query cctx -h 0x7d7258c5f20354572e9e92a300cb3078daa563f75cbb612366430c0299ac7e4e
```

下面的訊息就顯示了兩條鏈分別的交易Hash、誰發送交易、誰接收Message、以及傳送的Message等等詳細訊息

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764075755320-image.png)

Qwen API

用第一天的API KEY去發送Request，用法參考[API References](https://modelstudio.console.alibabacloud.com/?tab=api&accounttraceid=24b70361d9e8495eabc5a296e2810dffbibj#/api)

接著用Postman送Post的request就行

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-25-1764076777112-image.png)
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->













# **Day1 - Envrionment**

Zetachain

Zetachain是條Layer1的區塊鏈，有自己的共識機制，目標主要是做一條通用(Universal)區塊鏈，可以連接、讀寫所有鏈

要開始使用Zetachain，要先裝CLI

```
npm install -g zetachain
```

安裝完成後可以用下面指令去試用，並查詢zetachain支援的鏈

```
zetachain query chains list
```

接下來如果要進行開發，官方建議在本地用他們的工具\[Localnet\]([https://www.zetachain.com/docs/reference/localnet/)進行開發，可以輕鬆測試跨鏈邏輯，下面指令可以一鍵啟動](https://www.zetachain.com/docs/reference/localnet/\)%E9%80%B2%E8%A1%8C%E9%96%8B%E7%99%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BC%95%E9%AC%86%E6%B8%AC%E8%A9%A6%E8%B7%A8%E9%8F%88%E9%82%8F%E8%BC%AF%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%8C%87%E4%BB%A4%E5%8F%AF%E4%BB%A5%E4%B8%80%E9%8D%B5%E5%95%9F%E5%8B%95)

```
npx zetachain@latest localnet start
```

成功後可看到各條鏈的相關合約地址，如下圖

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763968437688-image.png)

## 初始化專案

如果要啟動Zetachain的項目，可以用下面的指令

```
npx zetachain@latest new --project hello

cd hello

yarn

forge soldeer update
```

那接下來可以開始嘗試在本地鏈部屬合約，那部屬合約需要一個部屬者，這裡用Anvil事先提供好已經有Gasfee的地址

```
PRIVATE_KEY=$(jq -r ‘.private_keys[0]’ ~/.zetachain/localnet/anvil.json) && echo $PRIVATE_KEY
```

那設定好部屬者的PRIVATE\_KEY就可以部屬合約在Zetachain了

```
UNIVERSAL=$(forge create Universal \

--rpc-url http://localhost:8545 \

--private-key $PRIVATE_KEY \

--evm-version paris \

--broadcast \

--json | jq -r .deployedTo) && echo $UNIVERSAL
```

那我們應該如何呼叫這個在Zetachain上的合約呢，我們可以任意選一條鏈，並將他的Gateway contract的地址找出來，那我們接下來要做的就是與這個Gateway contract互動，請他幫我們把訊息打到我們剛剛在Zetachain上部屬的合約

下面的指令可以直接幫我們抓Ethereum Sepolia的Gateway contract

```
GATEWAY_EVM=$(jq -r ‘.[“11155112”].contracts[] | select(.contractType == “gateway”) | .address’ ~/.zetachain/localnet/registry.json) && echo $GATEWAY_EVM
```

接下來用ZetaChain CLI內建call Gateway contract傳遞Hello到我們部屬的合約

```
npx zetachain evm call \

--rpc http://localhost:8545 \

--gateway $GATEWAY_EVM \

--receiver $UNIVERSAL \

--private-key $PRIVATE_KEY \

--types string \

--values hello
```

## Qwen

查了一下Qwen的背景，是由alibabacloud推出的大語言模型，但是他完全開源，所以可以調用官方的API去使用，或是本地自己部屬運行也可以

登入之後就可以創建API Key

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763968585600-image.png)

###   
微信群  
  

![](image.jpg)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/qwe638853/images/2025-11-24-1763999194679-image.png)
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
