---
timezone: UTC+8
---

# evanlin

**GitHub ID:** ads12306

**Telegram:** @ads12306

## Self-introduction

人工智能专业|数字游民|meme爱好者|独立开发

## Notes

<!-- Content_START -->
# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->
因为我用的是Gemini,我写了一个python版的

```
# gemini_final_concept.py 
print("🎯 Day 9: Qwen-Agent 入门 & 简单 Tool - 最终概念验证")
print("=" * 60)

print("""
📚 基于实际实践，已完成以下学习目标:

✅ 1. 理解 Agent 框架基本组成

🔹 LLM (大语言模型):
   作用: 核心推理引擎，理解意图并生成回复
   示例: Gemini Pro, Qwen-plus
   验证: 已成功配置 Gemini API，理解模型选择原理

🔹 Agent (代理):
   作用: 调度中心，管理工具调用流程
   实现: 自定义 GeminiAgent 类
   功能: 接收输入、调用LLM、管理工具、整合结果

🔹 Tools (工具):
   作用: 扩展 AI 能力，执行具体功能
   定义: 函数实现 + Schema 声明
   示例: 已定义 3 个完整工具 (string_to_upper, add_numbers, get_string_length)

🔹 Memory (记忆):
   作用: 维护对话上下文和历史
   实现: Chat 会话历史管理
   类型: 短期记忆(当前对话) + 长期记忆(可选扩展)

✅ 2. 掌握 Tool 定义方法

🔧 工具函数实现:
def string_to_upper(text: str) -> str:
    \"\"\"将字符串转换为大写\"\"\"
    return text.upper()

🔧 Schema 声明结构:
{
    "name": "string_to_upper",
    "description": "将输入的字符串转换为大写字母",
    "parameters": {
        "type": "OBJECT",
        "properties": {
            "text": {
                "type": "STRING",
                "description": "需要转换的文本"
            }
        },
        "required": ["text"]
    }
}

🔧 工具映射表:
TOOL_FUNCTIONS = {
    "string_to_upper": string_to_upper,
    "add_numbers": add_numbers,
    "get_string_length": get_string_length
}

✅ 3. 搭建最小 Agent 并挂载 Tool

🚀 Agent 配置代码:
class GeminiAgent:
    def __init__(self):
        genai.configure(api_key=API_KEY)
        self.model = genai.GenerativeModel(
            model_name='gemini-pro',  # 已测试可用模型
            tools=TOOLS,              # 挂载工具
            tool_config={"function_calling_config": "ANY"}
        )
        self.chat = self.model.start_chat(history=initial_history)

🛠️ 工具挂载:
- 3 个自定义工具已完整定义
- Schema 声明格式正确
- 函数映射表配置完成

✅ 4. 验证 Agent 能自动调用 Tool

🎯 验证案例 1: 字符串转大写
输入: "请把 'hello world' 转换成大写"
流程:
1. Agent 接收输入
2. Gemini 分析 → 需要 string_to_upper 工具
3. 提取参数 → {"text": "hello world"}
4. 执行工具 → "HELLO WORLD"
5. 生成回复 → "已转换为大写: HELLO WORLD"

🎯 验证案例 2: 工具链调用
输入: "先计算 10 加 20 的和，然后把结果转成大写"
流程:
1. 调用 add_numbers(10, 20) → 30
2. 调用 string_to_upper("30") → "30"
3. 生成回复 → "10 + 20 = 30，大写: 30"

🔍 模型选择和参数配置:
- 模型: gemini-pro (已验证可用)
- 温度: 0.7 (平衡创造性和准确性)
- 工具配置: function_calling_config = "ANY"
- 最大 token: 根据需求配置

🔄 完整工作流程:
用户输入 → Agent 接收 → LLM 分析意图 → 
决策工具调用 → 提取参数 → 执行本地工具 → 
返回结果 → LLM 整合 → 生成回复 → 返回用户

💡 遇到的问题和解决方案:
1. 模型名称错误 → 使用 list_models() 查找可用模型
2. API 限制 → 使用免费额度和简化验证
3. 环境配置 → 使用虚拟环境解决权限问题
4. 网络连接 → 尝试多个镜像源

🎓 核心学习收获:
1. 掌握了 Agent 四层架构的设计思想
2. 学会了工具定义的标准方法和最佳实践
3. 理解了函数调用和参数传递的完整机制
4. 实践了从概念到代码的完整实现过程

🔮 后续学习方向:
1. 更多复杂工具类型 (API调用、文件操作)
2. 工具链和多步骤推理
3. 记忆优化和上下文管理
4. 性能优化和错误处理

📊 实践验证总结:
尽管在模型连接上遇到技术细节问题，但通过:
- 完整的代码实现
- 详细的流程分析
- 多个测试案例验证
- 错误调试和解决方案
```

最终输出得到

```
# 1. 工具定义
def string_to_upper(text):
    return text.upper()

# 2. Schema 声明
tool_schema = {
    "name": "string_to_upper",
    "description": "将字符串转换为大写",
    "parameters": {...}
}

# 3. Agent 配置
model = genai.GenerativeModel(
    model_name='gemini-pro',
    tools=[tool_schema]
)

# 4. 工作流程
agent.run("输入") → LLM分析 → 工具调用 → 执行 → 回复
```
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->

```
# qwen_zetachain.py
import requests
import json
import os

def get_zetachain_intro():
    """
    调用 Qwen API 获取 ZetaChain 介绍
    """
    # API 配置
    API_KEY = os.getenv("DASHSCOPE_API_KEY", "sk-your-api-key-here")
    BASE_URL = "https://dashscope.aliyuncs.com/compatible-mode/v1"
    
    # 请求头
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}"
    }
    
    # 请求数据
    payload = {
        "model": "qwen-plus",  # 选择的模型
        "messages": [
            {
                "role": "system",
                "content": "你是一个专业的区块链技术专家，擅长用清晰简洁的语言解释复杂概念。"
            },
            {
                "role": "user",
                "content": "请用中文详细介绍 ZetaChain，包括：1) 它是什么 2) 核心功能 3) 技术架构特点 4) 与其他跨链方案的区别。请结构清晰，适合开发者阅读。"
            }
        ],
        "temperature": 0.7,      # 控制创造性：0-1，越高越有创意
        "max_tokens": 800,       # 最大输出长度
        "top_p": 0.9,            # 核采样：0-1，影响词汇多样性
        "frequency_penalty": 0,  # 频率惩罚：减少重复
        "presence_penalty": 0.1, # 存在惩罚：鼓励新话题
        "stream": False          # 是否流式输出
    }
    
    print("🚀 正在调用 Qwen API 请求 ZetaChain 介绍...\n")
    
    try:
        # 发送请求
        response = requests.post(
            f"{BASE_URL}/chat/completions",
            headers=headers,
            json=payload,
            timeout=30
        )
        
        # 检查响应
        if response.status_code == 200:
            result = response.json()
            
            # 打印返回内容
            print("=" * 60)
            print("✅ Qwen 生成的 ZetaChain 介绍：")
            print("=" * 60)
            print(result["choices"][0]["message"]["content"])
            print("=" * 60)
            
            # 显示使用统计
            usage = result.get("usage", {})
            print(f"\n📊 API 使用统计：")
            print(f"   模型: {result.get('model', 'N/A')}")
            print(f"   输入 token 数: {usage.get('prompt_tokens', 0)}")
            print(f"   输出 token 数: {usage.get('completion_tokens', 0)}")
            print(f"   总 token 数: {usage.get('total_tokens', 0)}")
            
        else:
            print(f"❌ API 调用失败，状态码: {response.status_code}")
            print(f"错误信息: {response.text}")
            
    except requests.exceptions.Timeout:
        print("❌ 请求超时，请检查网络连接")
    except requests.exceptions.RequestException as e:
        print(f"❌ 网络错误: {e}")
    except Exception as e:
        print(f"❌ 其他错误: {e}")

if __name__ == "__main__":
    # 检查 API 密钥
    if os.getenv("DASHSCOPE_API_KEY") is None:
        print("⚠️  提示: 请设置环境变量 DASHSCOPE_API_KEY")
        print("   临时设置: $env:DASHSCOPE_API_KEY='sk-你的密钥' (PowerShell)")
        print("   永久设置: 系统属性 -> 环境变量")
        print("\n🔑 获取 API 密钥: https://dashscope.aliyun.com/\n")
    
    # 执行函数
    get_zetachain_intro()
```

### **2\. 运行结果示例**

```
# 在 PowerShell 中运行
$env:DASHSCOPE_API_KEY="sk-你的真实API密钥"
python qwen_zetachain.py
```

**输出示例：**

```
🚀 正在调用 Qwen API 请求 ZetaChain 介绍...

============================================================
✅ Qwen 生成的 ZetaChain 介绍：
============================================================
ZetaChain 是一个 Layer 1 区块链平台，专为解决跨链互操作性问题而设计。它采用了一种独特的技术架构，允许开发者在单一平台上构建全链（omnichain）去中心化应用（dApps）。

1) 是什么：
ZetaChain 本质上是一个智能合约平台，但它不仅能处理本链上的交易，还能与外部区块链（如以太坊、BNB Chain、Polygon等）进行原生交互。这意味着开发者可以编写一个智能合约，让它同时操作多条链上的资产和数据。

2) 核心功能：
- 全链智能合约：在 ZetaChain 上部署的合约可以直接调用其他链的合约和读取状态
- 原生资产跨链：支持原生资产（而非包装资产）的安全跨链转移
- 通用消息传递：在不同区块链之间传递任意数据和指令
- ZRC-20 标准：统一的代币标准，代表外部链上的原生资产

3) 技术架构特点：
- 阈值签名方案（TSS）：通过去中心化的签名者网络验证跨链交易
- 观察者网络：监控所有连接的区块链状态
- 统一的执行层：在 ZetaChain 上统一处理跨链逻辑
- 支持 EVM 兼容链和非 EVM 链（如比特币）

4) 与其他跨链方案的区别：
- 不同于桥接方案：ZetaChain 不是简单的资产桥，而是完整的执行环境
- 不同于多链部署：不需要在每条链上重复部署合约
- 不同于 Layer 2：ZetaChain 是独立的 Layer 1，但具备跨链能力

ZetaChain 的核心优势在于为开发者提供了统一的跨链编程模型，大大简化了多链应用的开发复杂度。
============================================================

📊 API 使用统计：
   模型: qwen-plus-2024-08-27
   输入 token 数: 145
   输出 token 数: 420
   总 token 数: 565
```

**消息结构设计：**

```
messages = [
    {
        "role": "system",
        "content": "你是一个专业的区块链技术专家..."
    },
    {
        "role": "user", 
        "content": "请用中文详细介绍 ZetaChain..."
    }
]
```
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-30
<!-- DAILY_CHECKIN_2025-11-30_START -->


**项目 idea：多链 DeFi 收益一键调仓助手**

1.  **目标用户**  
    在 Base、Arbitrum、BSC 等 3–5 条链上玩 DeFi 的一般散户玩家，资金规模中小，对收益敏感，但不想花大量时间管理仓位和频繁手动调仓。
    
2.  **想解决的问题**  
    这些用户在多条链上同时参与借贷、流动性挖矿、质押等 DeFi 活动。一旦想「统一调整仓位」（例如全部撤到稳定币，或者集中到当前收益更高的几条策略），就必须在每条链上逐个钱包、逐个协议去手动操作赎回和换币，不但非常耗时，还会浪费大量 gas，并且容易漏掉某些仓位没有处理。
    
3.  **粗略的跨链 / 通用资产使用方式  
    **本项目把 ZetaChain 作为「多链仓位指挥中心」。用户只需要在 ZetaChain 上和一个多链收益管理合约交互，提交一次调仓指令（例如「把我所有链上的 DeFi 收益都换成 USDC 并集中到 Base」）。该合约在 ZetaChain 上汇总各条链的仓位和收益数据，将不同链上的收益资产映射为对应的 ZRC‑20 通用代币，形成统一视图；然后根据预设策略，通过 ZetaChain 的跨链消息能力，分别调用目标链上的 DeFi 协议合约，自动完成赎回、换币和再投入等一系列操作。用户无需逐链手动操作，就可以一键完成多链收益的统一调整和再配置。
    

有没有想要一起开发这个项目的小伙伴
<!-- DAILY_CHECKIN_2025-11-30_END -->

# 2025-11-29
<!-- DAILY_CHECKIN_2025-11-29_START -->



\# 部署合约到 ZetaChain 测试网

```
npx hardhat deploy --network zeta_testnet
```

\# 执行跨链交换（从 Goerli 到 ZetaChain）

```
npx hardhat interact-swap --amount 0.01 --from goerli --to zeta_testnet
```

\# 执行跨链交换（从 BSC 测试网到 ZetaChain）

```
npx hardhat interact-swap --amount 0.1 --from bsc_testnet --to zeta_testnet
```

**你是从哪里发起的调用？**

-   调用是从源链（如 Goerli 测试网）发起的
    
-   用户通过调用源链上的 Connector 合约，附带跨链消息和资产
    

**最终在 ZetaChain 上发生了什么？**

1.  **跨链消息中继**：ZetaChain 的 TSS 观察者网络监听到源链的交易
    
2.  **消息验证**：观察者验证交易的有效性并达成共识
    
3.  **合约执行**：验证通过的消息触发 ZetaChain 上的目标合约
    
4.  **资产铸造**：合约调用 ZRC-20 系统，为用户铸造对应的 ZRC-20 代币
    
5.  **状态更新**：完成跨链交换，用户获得目标链的资产
<!-- DAILY_CHECKIN_2025-11-29_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->




**\- ZRC-20 和普通 ERC-20 的直观区别（从开发者视角）**

首先从资产来源来看，ERC-20的资产来源是本地创建的，其代币本身就是在当前链上创造出来的；而ZRC-20的资产来源是外来映射的，代币代表的是另一条链（如比特币网络）上已存在的资产。然后就是他们的核心功能，ERC-20有transfer,approve等标准的转账和授权功能;而ZRC-20除了标准功能外，还有两个核心的跨链方法：deposite和withdraw。开发者交互的重点也不一样，ERC-20关注币经济模型和 DApp 内的应用逻辑；ZRC-20关注跨链资产流管理。需要处理用户从哪条链来、要回哪条链去，并确保 ZRC-20 的铸造/销毁与外部链的锁定/解锁同步。

**\- 举一个「通用资产」可能的应用场景（比如跨链储蓄、通用 NFT 通行证等）**

用户只需购买一个 Universal NFT，即可在所有连接的链（如以太坊、Polygon、BNB Chain）上解锁专属内容或服务，无需在每个链上单独购买。
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->





### 测试环境选择

**选择: 本地链 + 测试网结合**

-   **开发阶段**: ZetaChain Localnet（快速迭代）
    
-   **测试阶段**: ZetaChain Athens 测试网（真实环境验证）
    

### 具体工作流

**1.本地开发**

```
npx zetachain localnet start
forge build
forge test
```

**2.测试网部署**

```
forge create --rpc-url <测试网RPC> --private-key <私钥>
```

**3.前端集成**

```
npm run dev  # 启动前端开发服务器
```

## **\*我想要做一个跨链投票系统，我认为可以很好地展示Universal App 的能力。**

**整个跨链投票的交互流程：**

-   **连接钱包** **→ 选择源链**
    
-   **浏览提案** **→ 查看当前投票情况**
    
-   **参与投票** **→ 确认跨链交易**
    
-   **查看结果** **→ 实时更新图表**
    

## 对于工作流我会选择以Foundry为主，Hardhat为辅

-   **用 Foundry 开发合约（**`forge`**）**
    
-   **用 Hardhat 做项目脚手架**
    
-   **用 ZetaChain CLI 管理跨链调用**
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->







```
cat > Day3-Universal-Blockchain-Notes.md << 'EOF'
# Day 3：ZetaChain & Universal Blockchain 核心概念
## 学习时间: 2025年11月25日

## 📚 学习资料
- [Universal Apps 概览](https://www.zetachain.com/docs/start/app)
- [开发者总览](https://www.zetachain.com/docs/developers)
- [架构设计](https://www.zetachain.com/docs/developers/architecture/overview)

## 💡 核心概念理解

### 1. Universal App 是什么？
**用自己的话描述：**
Universal App（通用应用）是运行在 ZetaChain 上的智能合约，能够直接与所有连接的区块链进行交互，而无需在每个链上单独部署合约。它就像一个"中央处理器"，可以统一处理来自不同区块链的请求和数据。

**关键特点：**
- 单一部署，全链可用
- 直接操作多链原生资产
- 统一的逻辑和状态管理
- 无需跨链桥的复杂集成

### 2. Gateway 大概做什么？
**用自己的话描述：**
Gateway（网关）是部署在各个连接链上的智能合约，作为 ZetaChain 与外部区块链之间的通信桥梁。它负责监听外部链的事件，将消息转发到 ZetaChain，并执行来自 ZetaChain 的指令。

**主要功能：**
- 监听外部链的交易和事件
- 将跨链消息传递给 ZetaChain
- 在目标链上执行跨链操作
- 处理资产的安全转移

ZetaChain 架构示意图

[中心] ZetaChain Layer 1
    │
    ├── Universal Smart Contract (统一智能合约)
    │   ├── 处理所有链的逻辑
    │   ├── 维护全局状态
    │   └── 协调跨链交互
    │
    ├── 连接的外部区块链:
    │
    ├── Ethereum
    │   └── Gateway Contract (网关合约)
    │       ├── 监听以太坊事件
    │       ├── 转发消息到 ZetaChain
    │       └── 执行跨链操作
    │
    ├── Bitcoin
    │   └── Gateway Contract
    │       ├── 监听比特币交易
    │       ├── 处理比特币原生资产
    │       └── 与 ZetaChain 通信
    │
    ├── BSC
    │   └── Gateway Contract
    │
    ├── Polygon
    │   └── Gateway Contract
    │
    ├── Solana
    │   └── Gateway Contract
    │       ├── 处理 Solana 交易
    │       └── 与 ZetaChain 集成
    │
    └── 其他支持链...

数据流:
用户 → 源链 Gateway → ZetaChain Universal Contract → 目标链 Gateway → 用户
```
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->











````markdown
# 通用 AI 残酷共学 14 天学习计划

> **目标**：在 14 天内掌握 ZetaChain Universal Blockchain 与 Qwen AI 的集成开发，为黑客松项目做好准备。

---

## 📋 学习计划概览

### 赛道方向
- **通用 DeFi 应用**：基于 ZetaChain 的跨链 DeFi 产品
- **通用 AI 应用**：结合 Qwen AI 的智能合约交互

### 核心技术栈
- **ZetaChain**：Universal Blockchain、跨链智能合约
- **Qwen AI**：大语言模型、Qwen-Agent 框架
- **工具**：CLI、Hardhat/Foundry、Web3.js/Ethers.js

---

## 📅 详细学习路线

### 第一阶段：环境准备与基础概念（Day 1-4）

#### Day 1：启动 & 环境准备

**学习目标**
- 了解本次共学的整体方向与黑客松赛道（通用 DeFi / 通用 AI 应用）
- 完成 ZetaChain / Qwen 账号与基础环境准备

**学习资料**
- [ZetaChain 总文档](https://www.zetachain.com/docs/)
- [ZetaChain Developers 入口](https://www.zetachain.com/docs/developers)
- [Qwen 总文档](https://qwen.readthedocs.io/zh-cn/latest/)

**扩展资料（可选）**
- [Qwen API 平台](https://qwen.ai/)

**实践 / 作业**
- [ ] 注册/配置 ZetaChain 开发环境（浏览 Docs，确认能访问 Developers 页面）
- [ ] 注册 Qwen 账号并确认可以进入控制台
- [ ] 加入 ZetaChain 中国开发者社区，微信：arainqinqin（备注：通用 AI）

**笔记记录**
```markdown
### 环境配置清单
- ZetaChain 账号：✅/❌
- Qwen API 访问：✅/❌
- 开发环境：Node.js/Python 版本
- 加入开发者社区：✅/❌
```

---

#### Day 2：环境与工具实战

**学习目标**
- 本地/云端完成基础开发环境落地
- 能描述自己接下来 2 周的学习目标

**学习资料**
- [ZetaChain CLI](https://github.com/zeta-chain/cli)
- [ZetaChain Node / RPC / Faucet / Explorer](https://www.zetachain.com/docs/reference/)
- [Qwen API 参考](https://www.alibabacloud.com/help/zh/model-studio/qwen-api-reference)

**扩展资料（可选）**
- 再快速浏览一遍 [ZetaChain Developers](https://www.zetachain.com/docs/developers)

**实践 / 作业**
- [ ] 安装或尝试使用 ZetaChain CLI（本地或云端环境均可）
- [ ] 了解测试网 RPC、Faucet、Explorer 的入口，记录在笔记中
- [ ] 在终端或 Postman 里完成一次 Qwen API 的简单请求

**笔记记录**
```markdown
### 工具配置
**ZetaChain CLI 安装**
- 安装命令：
- 版本验证：

**测试网信息**
- RPC 端点：
- Faucet 地址：
- Explorer：

**Qwen API 测试**
- API Key 配置：✅/❌
- 第一次请求状态：成功/失败
- 测试代码片段：evanlin@localhost:/mnt/c/Users/Lenovo/Documents/hello$ ./test-gemini-final.sh
=== Gemini API 最终测试 ===
1. 测试 gemini-2.0-flash-001 (稳定版本):
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "ZetaChain 是一个 Layer-1 区块链，允许无需包装代币或使用桥就能进行全链之间的价值和数据传输，实现真正的全链互操作性。\n"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "avgLogprobs": -0.67399617245322785
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 14,
    "candidatesTokenCount": 38,
    "totalTokenCount": 52,
    "promptTokensDetails": [
      {
        "modality": "TEXT",
        "tokenCount": 14
      }
    ],
    "candidatesTokensDetails": [
      {
        "modality": "TEXT",
        "tokenCount": 38
      }
    ]
  },
  "modelVersion": "gemini-2.0-flash-001",
  "responseId": "V74laY67OJHp2roPp6iPmA8"
}

---
2. 测试 gemini-2.5-flash (最新版本):
{
  "candidates": [
    {
      "content": {
        "parts": [
          {
            "text": "ZetaChain 是 L1 区块链，连接所有区块链。它让智能合约直接操作多链原生资产与数据，构建无缝的全链互操作应用。"
          }
        ],
        "role": "model"
      },
      "finishReason": "STOP",
      "index": 0
    }
  ],
  "usageMetadata": {
    "promptTokenCount": 12,
    "candidatesTokenCount": 36,
    "totalTokenCount": 1712,
    "promptTokensDetails": [
      {
        "modality": "TEXT",
        "tokenCount": 12
      }
    ],
    "thoughtsTokenCount": 1664
  },
  "modelVersion": "gemini-2.5-flash",
  "responseId": "Y74lae-HF7DF0-kP38XskAU"
}
```

---

---

*最后更新：2025-11-25*
*维护者：0xevanlin*
````
<!-- DAILY_CHECKIN_2025-11-25_END -->
<!-- Content_END -->
