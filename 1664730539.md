---
timezone: UTC+8
---

# 邵俊

**GitHub ID:** 1664730539

**Telegram:** @pig1664730539

## Self-introduction

一名乐于学习的小白

## Notes

<!-- Content_START -->
# 2025-12-04
<!-- DAILY_CHECKIN_2025-12-04_START -->
改编的官方示例代码：

```python
import json
import os

import json5
import urllib.parse
from qwen_agent.agents import Assistant
from qwen_agent.tools.base import BaseTool, register_tool

llm_cfg = {
    'model': 'qwen-max',
    'model_server': 'dashscope',
    'generate_cfg': {
        'top_p': 0.8
    }
}

system = 'According to the user\'s request, you first draw a picture and then automatically run code to download the picture ' + \
         'and select an image operation from the given document to process the image'

@register_tool('my_image_gen')
class MyImageGen(BaseTool):
    description = 'AI painting (image generation) service, input text description, and return the image URL drawn based on text information.'
    parameters = [{
        'name': 'prompt',
        'type': 'string',
        'description': 'Detailed description of the desired image content, in English',
        'required': True
    }]

    def call(self, params: str, **kwargs) -> str:
        prompt = json5.loads(params)['prompt']
        prompt = urllib.parse.quote(prompt)
        return json.dumps(
            {'image_url': f'https://image.pollinations.ai/prompt/{prompt}'},
            ensure_ascii=False)


tools = ['my_image_gen', 'code_interpreter']


bot = Assistant(
    llm=llm_cfg,
    system_message=system,
    function_list=tools
)

print("=" * 50)
print("Qwen-Agent 图片生成助手已启动！")
print("输入问题即可，输入 'quit' 退出")
print("=" * 50)

messages = []
while True:
    query = input('\n你的问题: ')
    if query.lower() == 'quit':
        break
    
    messages.append({'role': 'user', 'content': query})
    response = []
    for response in bot.run(messages=messages):
        print('机器人回复:', response)
    messages.extend(response)
```

```python
import json
from qwen_agent.agents import Assistant
from qwen_agent.tools.base import BaseTool, register_tool

llm_cfg = {
    'model': 'qwen-max',
    'model_server': 'dashscope',
    # 'api_key': 'sk-你的密钥',
}


# 工具1：字符串转大写
@register_tool('to_uppercase')
class ToUppercase(BaseTool):
    description = '将输入的字符串转换为大写字母'
    parameters = [{
        'name': 'text',
        'type': 'string',
        'description': '需要转换的字符串',
        'required': True
    }]

    def call(self, params: str, **kwargs) -> str:
        params_dict = json.loads(params)
        text = params_dict['text']
        result = text.upper()
        return json.dumps({
            'original': text,
            'uppercase': result
        }, ensure_ascii=False)



@register_tool('add_numbers')
class AddNumbers(BaseTool):
    description = '计算两个数字的和'
    parameters = [
        {
            'name': 'a',
            'type': 'number',
            'description': '第一个数字',
            'required': True
        },
        {
            'name': 'b',
            'type': 'number',
            'description': '第二个数字',
            'required': True
        }
    ]

    def call(self, params: str, **kwargs) -> str:
        params_dict = json.loads(params)
        a = params_dict['a']
        b = params_dict['b']
        result = a + b
        return json.dumps({
            'a': a,
            'b': b,
            'sum': result
        }, ensure_ascii=False)



tools = ['to_uppercase', 'add_numbers']


bot = Assistant(
    llm=llm_cfg,
    system_message='你是一个助手，可以帮用户转换大写字母和计算加法。',
    function_list=tools
)


print("=" * 50)
print("自定义工具助手已启动！")
print("输入 'quit' 退出")
print("=" * 50)

messages = []
while True:
    query = input('\n你的问题: ')
    if query.lower() == 'quit':
        break
    
    messages.append({'role': 'user', 'content': query})
    response = []
    for response in bot.run(messages=messages):
        print('回复:', response)
    messages.extend(response)
```

  
已经帮您将 "hello world" 转换成了大写，结果是 "HELLO WORLD
<!-- DAILY_CHECKIN_2025-12-04_END -->

# 2025-12-03
<!-- DAILY_CHECKIN_2025-12-03_START -->

```python
import requests
import json


api_key = "......................"

url = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation"
headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {api_key}"
}


data = {
    "model": "qwen-turbo", 
    "input": {
        "prompt": "你好，请生成一段对zetachain的介绍"
    },
    "parameters": {}
}


response = requests.post(url, headers=headers, data=json.dumps(data))


print("Status Code:", response.status_code)
print("Response Body:", response.text)
```

  
  
PS D:\\Desktop> python test\_[qwen.py](http://qwen.py)

Status Code: 200

Response Body: {"output":{"finish\_reason":"stop","text":"你好！ZetaChain 是一个跨链智能合约平台，旨在为开发者提供一个去中心化、可扩展且安全的环境，用于构建和部署跨链应用程序（dApps）。它通过将区块链网络连接在一起，使不同链上的资产和数据可以互相访问和交互，从而实现真正的跨链互操作性。\\n\\nZetaChain 的核心特点包括：\\n\\n1. **跨链智能合约**：开发者可以在 ZetaChain 上编写智能合约，这些合约可以与多个不同的区块链网络进行交互，例如 Ethereum、BSC、Solana 等。\\n\\n2. **去中心化预言机**：ZetaChain 提供了一个去中心化的预言机系统，允许智能合约安全地获取外部数据，从而增强其功能和应用场景。\\n\\n3. **兼容性与可扩展性**：ZetaChain 设计为高度兼容的平台，支持多种区块链协议，并具备良好的可扩展性，以适应不断增长的用户需求。\\n\\n4. **安全性**：通过采用先进的密码学技术和去中心化架构，ZetaChain 保障了交易的安全性和数据的完整性。\\n\\nZetaChain 的目标是推动 Web3 生态系统的进一步发展，使开发者能够更轻松地构建跨链应用，提升用户体验，并促进不同区块链之间的价值流动。"},"usage":{"input\_tokens":22,"output\_tokens":266,"prompt\_tokens\_details":{"cached\_tokens":0},"total\_tokens":288},"request\_id":"b8ef6039-7e6c-45ab-aceb-89daf85cfe39"}
<!-- DAILY_CHECKIN_2025-12-03_END -->

# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->


-   **_想法：跨链贷款聚合器_**
    
-   目标用户：需要多次大量贷款的人，需要多次比较利率的人，需要学习体验贷款的人
    
-   想解决的问题：  
    比较利率需要多个平台的查看，收集，比较，步骤繁多复杂；  
    在多平台贷款需要多次跳转平台，十分麻烦；  
    若贷了多个款或贷了不同平台的款，支付手续费需要在多个平台跳转，十分麻烦；  
    从未在DeFi上贷过款的小白面于多平台、多链、多货币复杂，学习困难；  
    人为处理消化数据速度慢，聚合器可以快速处理数据并且给出推荐贷款方案，给出用户大概的方向与方案；  
    贷款后的资产流转可能会多次包装，安全性低。
    
-   粗略的跨链 / 通用资产使用方式：  
    1.使用通用智能和约分析各链的利率并选择最优  
    2.利用zetachain原生资产支持，减少包装，增加安全性  
    3.利用通用智能合约统一贷款的操作界面，集成管理各贷款状态  
    4.利用zetachain的跨链交易能力，统一支付手续费与还款
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->



DAY6：  
DEMO：  
1.配置环境npx zetachain@latest new --project hello

cd hello

yarn

forge soldeer update  
2.定义变量$PRIVATE\_KEY,$UNIVERSAL  
3.发送命令：npx zetachain evm call \\

\--chain-id 84532 \\

\--receiver $UNIVERSAL \\

\--private-key $PRIVATE\_KEY \\

\--types string \\

\--values hello  
4.检查：Transaction hash: 0x529bF40A3B6AeEbAe0c40Ba35A6aFfc86b8b155b  
npx zetachain query cctx --hash 0x529bF40A3B6AeEbAe0c40Ba35A6aFfc86b8b155b  

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/1664730539/images/2025-12-01-1764579276730-image.png)
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->




-   ZRC-20 和普通 ERC-20 的直观区别（从开发者视角）： 在zetachain中ZRC-20是别的链的资产转价过来的代币，具备跨链的能力。由于zetachain兼容以太坊虚拟机，因此ERC-20是zetachain本地部署的代币，它并不具备跨链能力
    
-   举一个「通用资产」可能的应用场景（比如跨链储蓄、通用 NFT 通行证等）： 使未来的区块链能够直接与过去的区块链跨链交易
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->








-   自己想做的第一个Universal App 想实现的“打印 / 记录 / 简单逻辑”是什么： 在以太坊上存取的数字1能被polygon的链上读取
    
-   为后续的 Hello World Demo 决定一种工作流： 1.使用CLI+Foundry 2.测试网
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->









1.universal app 是一个消除不同区块链之间的隔阂的环境。  
2.gateway 是实现作用的通道  

![未标题-1.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/1664730539/images/2025-11-26-1764137466056-___-1.png)
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->










zetachain重要链接

[RPC/API endpoints – ZetaChain Docs](https://www.zetachain.com/docs/reference/network/api)

[Faucet: Get Testnet Tokens – ZetaChain Docs](https://www.zetachain.com/docs/reference/faucet)

[Explorers – ZetaChain Docs](https://www.zetachain.com/docs/reference/explorers)

[Web3 Faucet](https://cloud.google.com/application/web3/faucet)

[All That Node | Dashboard](https://www.allthatnode.com/createproject.dsrv)

qwen  

```python
import requests
import json


api_key = "API-KEY"

url = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation"
headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {api_key}"
}


data = {
    "model": "qwen-turbo", 
    "input": {
        "prompt": "你好，请用一句话介绍一下你自己"
    },
    "parameters": {}
}


response = requests.post(url, headers=headers, data=json.dumps(data))


print("Status Code:", response.status_code)
print("Response Body:", response.text)
```
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->












| | | | | | | |

|   |   |   |
| --- | --- | --- |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
