---
timezone: UTC+8
---

# Gene

**GitHub ID:** 15998431520

**Telegram:** @Gene_front

## Self-introduction

å‰ç«¯ä¸€æš

## Notes

<!-- Content_START -->
# 2025-12-04
<!-- DAILY_CHECKIN_2025-12-04_START -->
### å†™å‡ºä¸€ä¸ªåç«¯ä¼ªä»£ç æˆ–ç®€å•å®ç°ï¼š

-   æ¥æ”¶ `parse_swap_intent` è¿”å›å€¼ï¼›
    
-   æ ¹æ®ä¸åŒé“¾ / ä¸åŒ token é€‰æ‹©å…·ä½“çš„åˆçº¦ / è°ƒç”¨æ–¹å¼ï¼›
    
-   æš‚æ—¶å¯ä»¥åªåœ¨æ§åˆ¶å°æ‰“å°â€œå‡†å¤‡å‘èµ·ä»€ä¹ˆäº¤æ˜“â€ã€‚
    

```
// swapExecutor.js

// å„é“¾æ”¯æŒçš„ DEXï¼ˆç®€åŒ–æè¿°ï¼‰
const DEX_ROUTER = {
  ethereum: "Uniswap V3 Router",
  base: "Base Swap / Uniswap V3",
  polygon: "QuickSwap / Uniswap V3",
  arbitrum: "SushiSwap / Uniswap V3"
};

// ä»£å¸åœ°å€æ˜ å°„ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨ Token List æˆ–é“¾ä¸ŠæŸ¥è¯¢ï¼‰
const TOKEN_ADDRESSES = {
  base: {
    USDC: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    ETH: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE" // Native ETH placeholder
  },
  polygon: {
    USDC: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
    MATIC: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
    WETH: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619"
  },
  ethereum: {
    USDC: "0xA0b86a33E6441E8C5c5d5f9c7d5f5f5f5f5f5f5f5",
    ETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" // WETH
  },
  arbitrum: {
    USDC: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
    ETH: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1" // WETH
  }
};

/**
 * æ‰§è¡Œ Swap æ„å›¾ï¼ˆæ¨¡æ‹Ÿï¼‰
 * @param {Object} intent - æ¥è‡ª parse_swap_intent çš„ç»“æœ
 * @param {string} intent.chain
 * @param {string} intent.tokenIn
 * @param {string} intent.tokenOut
 * @param {string} intent.amount
 * @returns {string} æ—¥å¿—æ¶ˆæ¯
 */
function executeSwapIntent(intent) {
  const { chain, tokenIn, tokenOut, amount } = intent;

  // 1. éªŒè¯é“¾æ˜¯å¦æ”¯æŒ
  const normalizedChain = chain.toLowerCase();
  if (!DEX_ROUTER[normalizedChain]) {
    const msg = `âŒ ä¸æ”¯æŒçš„é“¾: ${chain}`;
    console.log(msg);
    return msg;
  }

  // 2. è·å– DEX åç§°
  const dex = DEX_ROUTER[normalizedChain];

  // 3. æŸ¥æ‰¾ä»£å¸åœ°å€
  const chainTokens = TOKEN_ADDRESSES[normalizedChain] || {};
  const addrIn = chainTokens[tokenIn];
  const addrOut = chainTokens[tokenOut];

  if (!addrIn) {
    const msg = `âš ï¸ æœªçŸ¥ tokenIn ${tokenIn} on ${normalizedChain}`;
    console.log(msg);
    return msg;
  }
  if (!addrOut) {
    const msg = `âš ï¸ æœªçŸ¥ tokenOut ${tokenOut} on ${normalizedChain}`;
    console.log(msg);
    return msg;
  }

  // 4. æ‰“å°æ¨¡æ‹Ÿäº¤æ˜“ä¿¡æ¯
  const message = `
âœ… å‡†å¤‡å‘èµ·äº¤æ˜“:
  - é“¾: ${normalizedChain}
  - DEX: ${dex}
  - ä»: ${amount} ${tokenIn} (${addrIn})
  - æ¢æˆ: ${tokenOut} (${addrOut})
  - æ“ä½œ: è°ƒç”¨ router.swapExactTokensForTokens(...)
`.trim();

  console.log(message);
  return message;
}

// ===== æ¨¡æ‹Ÿè°ƒç”¨ç¤ºä¾‹ =====
if (require.main === module) {
  const testIntents = [
    { chain: "base", tokenIn: "USDC", tokenOut: "ETH", amount: "10" },
    { chain: "polygon", tokenIn: "USDC", tokenOut: "MATIC", amount: "50" }
  ];

  testIntents.forEach((intent, i) => {
    console.log("\n" + "=".repeat(50));
    executeSwapIntent(intent);
  });
}

// å¯¼å‡ºä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼ˆå¦‚ Express è·¯ç”±ï¼‰
module.exports = { executeSwapIntent };
```
<!-- DAILY_CHECKIN_2025-12-04_END -->

# 2025-12-03
<!-- DAILY_CHECKIN_2025-12-03_START -->

### è®¾è®¡ä¸€ä¸ªå·¥å…·ï¼šparse\_swap\_intent(text)ï¼Œè¿”å›ç»“æ„åŒ– JSON

```
import os
import re
import json
from qwen_agent.tools import BaseTool
from qwen_agent.agents import Assistant

# å¯ç”¨ Mock LLMï¼ˆæ— éœ€ API Keyï¼‰
os.environ["QWEN_AGENT_MOCK_LLM"] = "true"

# === 1. è‡ªå®šä¹‰å·¥å…·ï¼šè§£æ Swap æ„å›¾ ===
class ParseSwapIntentTool(BaseTool):
    name = "parse_swap_intent"
    description = (
        "ä»ç”¨æˆ·è‡ªç„¶è¯­è¨€ä¸­æå–ä»£å¸å…‘æ¢æ„å›¾ï¼Œè¿”å›ç»“æ„åŒ– JSONã€‚"
        "æ”¯æŒçš„é“¾ï¼šbase, ethereum, arbitrumï¼›ä»£å¸å¦‚ï¼šUSDC, ETH, DAI, WBTC ç­‰ã€‚"
    )
    parameters = [
        {
            "name": "text",
            "type": "string",
            "description": "ç”¨æˆ·è¾“å…¥çš„è‡ªç„¶è¯­è¨€ï¼Œä¾‹å¦‚ 'åœ¨ Base ä¸Šç”¨ 10 USDC æ¢ ETH'",
            "required": True,
        }
    ]

    def _run(self, text: str) -> str:
        # ç®€å•è§„åˆ™è§£æï¼ˆMVPï¼‰
        text_lower = text.lower()

        # é“¾è¯†åˆ«
        chain = "ethereum"  # é»˜è®¤
        if "base" in text_lower:
            chain = "base"
        elif "arbitrum" in text_lower:
            chain = "arbitrum"

        # æå–é‡‘é¢å’Œä»£å¸ï¼ˆç®€å•æ­£åˆ™ï¼‰
        # åŒ¹é…æ¨¡å¼å¦‚ï¼š10 USDC, 5.5 DAI, 1 eth
        amount_token_pattern = r'(\d+(?:\.\d+)?)\s+([a-z]+)'
        tokens = re.findall(amount_token_pattern, text_lower)

        token_in = None
        token_out = None
        amount = "0"

        # å‡è®¾ç¬¬ä¸€ä¸ªæåˆ°çš„ä»£å¸æ˜¯ tokenInï¼Œç¬¬äºŒä¸ªæ˜¯ tokenOut
        if len(tokens) >= 2:
            amount, token_in = tokens[0]
            _, token_out = tokens[1]
        elif len(tokens) == 1:
            amount, token_in = tokens[0]
            # å°è¯•ä»â€œæ¢/å…‘æ¢/ä¹°â€åæ‰¾ tokenOut
            if "æ¢" in text or "å…‘æ¢" in text or "buy" in text_lower or "for" in text_lower:
                # ç®€å•å¯å‘ï¼šå–æœ€åä¸€ä¸ªå•è¯ä½œä¸º tokenOutï¼ˆä¸ä¸¥è°¨ä½†å¤Ÿæ¼”ç¤ºï¼‰
                words = [w.strip('.,?!') for w in text.split()]
                for i, w in enumerate(words):
                    if w in ["æ¢", "å…‘æ¢", "for", "buy"]:
                        if i + 1 < len(words):
                            token_out = words[i + 1].upper()
        else:
            # å°è¯•ç›´æ¥å…³é”®è¯åŒ¹é…
            if "usdc" in text_lower:
                token_in = "USDC"
            if "eth" in text_lower or "ether" in text_lower:
                if not token_in:
                    token_in = "ETH"
                else:
                    token_out = "ETH"

        # é»˜è®¤å…œåº•
        if not token_in:
            token_in = "USDC"
        if not token_out:
            token_out = "ETH"

        result = {
            "chain": chain,
            "tokenIn": token_in.upper(),
            "tokenOut": token_out.upper(),
            "amount": amount
        }

        return json.dumps(result, ensure_ascii=False)

# === 2. åˆ›å»º Agent å¹¶æ³¨å†Œå·¥å…· ===
agent = Assistant(
    llm={'model': 'qwen-max'},
    function_list=[ParseSwapIntentTool()]
)

# === 3. æµ‹è¯•å¤šä¸ªç”¨æˆ·è¾“å…¥ ===
test_inputs = [
    "åœ¨ Base é“¾ä¸Šç”¨ 10 USDC æ¢ ETH",
    "æˆ‘æƒ³ç”¨ 5.5 DAI åœ¨ arbitrum ä¸Šå…‘æ¢ WBTC",
    "swap 20 USDC for ETH on base"
]

for user_input in test_inputs:
    print(f"\nğŸ“¥ ç”¨æˆ·è¾“å…¥: {user_input}")
    messages = [{'role': 'user', 'content': user_input}]
    response = list(agent.run(messages))

    # æ‰“å°æœ€ç»ˆå›ç­”
    final_msg = response[-1]
    print(f"ğŸ“¤ Agent å›å¤: {final_msg['content']}")

    # å¦‚æœå·¥å…·è¢«è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥æŸ¥çœ‹ä¸­é—´æ­¥éª¤
    for msg in response:
        if msg.get('role') == 'function' and msg.get('name') == 'parse_swap_intent':
            parsed = json.loads(msg['content'])
            print(f"âœ… è§£æç»“æœ: {parsed}")
```

### è®© Agent èƒ½å¤„ç†ä»¥ä¸‹è¾“å…¥ï¼š

-   â€œå¸®æˆ‘åœ¨ Base ä¸Šç”¨ 10 USDC æ¢æˆ ETHâ€
    
-   â€œæŠŠæˆ‘ 50 U å…‘æ¢æˆ Polygon ä¸Šçš„ MATICâ€
    

```
import os
import re
import json
from qwen_agent.tools import BaseTool
from qwen_agent.agents import Assistant

# å¯ç”¨ Mock LLMï¼ˆæ— éœ€ API Keyï¼‰
os.environ["QWEN_AGENT_MOCK_LLM"] = "true"

# ä»£å¸åˆ«åæ˜ å°„
TOKEN_ALIAS = {
    'u': 'USDC',
    'usd': 'USDC',
    'eth': 'ETH',
    'ether': 'ETH',
    'matic': 'MATIC',
    'weth': 'WETH',
    'dai': 'DAI',
    'wbtc': 'WBTC',
    'usdt': 'USDT',
    'usdc': 'USDC'
}

# é“¾åˆ«åæ˜ å°„ï¼ˆç»Ÿä¸€å°å†™ï¼‰
CHAIN_ALIAS = {
    'base': 'base',
    'polygon': 'polygon',
    'ethereum': 'ethereum',
    'eth': 'ethereum',
    'arbitrum': 'arbitrum',
    'arb': 'arbitrum'
}

class ParseSwapIntentTool(BaseTool):
    name = "parse_swap_intent"
    description = (
        "ä»ç”¨æˆ·è‡ªç„¶è¯­è¨€ä¸­æå–ä»£å¸å…‘æ¢æ„å›¾ï¼Œè¿”å›ç»“æ„åŒ– JSONã€‚"
        "æ”¯æŒé“¾ï¼šbase, polygon, ethereum, arbitrumï¼›ä»£å¸å¦‚ï¼šUSDC (æˆ–ç®€å†™ä¸º U), ETH, MATIC, DAI ç­‰ã€‚"
    )
    parameters = [
        {
            "name": "text",
            "type": "string",
            "description": "ç”¨æˆ·è¾“å…¥çš„è‡ªç„¶è¯­è¨€ï¼Œä¾‹å¦‚ 'å¸®æˆ‘åœ¨ Base ä¸Šç”¨ 10 USDC æ¢æˆ ETH'",
            "required": True,
        }
    ]

    def _run(self, text: str) -> str:
        text_clean = re.sub(r'[^\w\s]', ' ', text)  # ç§»é™¤æ ‡ç‚¹
        text_lower = text_clean.lower()

        # === 1. æå–é“¾ ===
        chain = "ethereum"  # é»˜è®¤
        for alias, canonical in CHAIN_ALIAS.items():
            if alias in text_lower:
                chain = canonical
                break

        # === 2. æå–é‡‘é¢å’Œä»£å¸ ===
        # åŒ¹é…æ•°å­—ï¼ˆæ•´æ•°æˆ–å°æ•°ï¼‰
        amount_match = re.search(r'(\d+(?:\.\d+)?)', text_lower)
        amount = amount_match.group(1) if amount_match else "0"

        # åˆ†è¯
        words = text_lower.split()

        # æŸ¥æ‰¾ tokenIn å’Œ tokenOut çš„ä½ç½®
        token_in = None
        token_out = None

        # å¯å‘å¼ï¼šé€šå¸¸ "ç”¨ X æ¢ Y" æˆ– "X å…‘æ¢ Y"
        # æ‰¾å…³é”®è¯ä½ç½®
        swap_keywords = ['æ¢', 'å…‘æ¢', 'æ¢æˆ', 'for', 'to', 'into']
        keyword_pos = -1
        for i, w in enumerate(words):
            if any(kw in w for kw in ['æ¢', 'å…‘æ¢']) or w in ['for', 'to']:
                keyword_pos = i
                break

        # æå– tokenInï¼šå…³é”®è¯å‰çš„ä»£å¸
        if keyword_pos > 0:
            for i in range(keyword_pos - 1, -1, -1):
                word = words[i]
                # å°è¯•åŒ¹é…ä»£å¸ï¼ˆè·³è¿‡æ•°å­—ï¼‰
                if word.replace('.', '', 1).isdigit():
                    continue
                if word in TOKEN_ALIAS:
                    token_in = TOKEN_ALIAS[word]
                    break
                # æ¨¡ç³ŠåŒ¹é…ï¼ˆå¦‚ "u"ï¼‰
                for alias in TOKEN_ALIAS:
                    if alias in word:
                        token_in = TOKEN_ALIAS[alias]
                        break
                if token_in:
                    break

        # æå– tokenOutï¼šå…³é”®è¯åçš„ä»£å¸
        if keyword_pos != -1 and keyword_pos + 1 < len(words):
            for i in range(keyword_pos + 1, len(words)):
                word = words[i]
                if word.replace('.', '', 1).isdigit():
                    continue
                if word in TOKEN_ALIAS:
                    token_out = TOKEN_ALIAS[word]
                    break
                for alias in TOKEN_ALIAS:
                    if alias in word:
                        token_out = TOKEN_ALIAS[alias]
                        break
                if token_out:
                    break

        # å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•å…¨å±€åŒ¹é…
        if not token_in or not token_out:
            found_tokens = []
            for word in words:
                if word in TOKEN_ALIAS:
                    found_tokens.append(TOKEN_ALIAS[word])
                else:
                    for alias in TOKEN_ALIAS:
                        if alias == word:  # ç²¾ç¡®åŒ¹é…åˆ«å
                            found_tokens.append(TOKEN_ALIAS[alias])
                            break
            # å»é‡ä½†ä¿æŒé¡ºåº
            seen = set()
            unique_tokens = []
            for t in found_tokens:
                if t not in seen:
                    unique_tokens.append(t)
                    seen.add(t)
            if len(unique_tokens) >= 2:
                token_in = unique_tokens[0]
                token_out = unique_tokens[1]
            elif len(unique_tokens) == 1:
                token_in = unique_tokens[0]
                token_out = "ETH"  # é»˜è®¤

        # æœ€ç»ˆå…œåº•
        token_in = token_in or "USDC"
        token_out = token_out or "ETH"

        result = {
            "chain": chain,
            "tokenIn": token_in,
            "tokenOut": token_out,
            "amount": amount
        }

        return json.dumps(result, ensure_ascii=False)


# === åˆ›å»º Agent ===
agent = Assistant(
    llm={'model': 'qwen-max'},
    function_list=[ParseSwapIntentTool()]
)

# === æµ‹è¯•ç”¨ä¾‹ ===
test_cases = [
    "å¸®æˆ‘åœ¨ Base ä¸Šç”¨ 10 USDC æ¢æˆ ETH",
    "æŠŠæˆ‘ 50 U å…‘æ¢æˆ Polygon ä¸Šçš„ MATIC",
    "åœ¨ Arbitrum ä¸Šç”¨ 25 DAI æ¢ WBTC",
    "swap 5 eth for usdc on base"
]

print("ğŸ” æµ‹è¯• Agent è‡ªåŠ¨è°ƒç”¨ parse_swap_intent å·¥å…·ï¼š\n")

for user_input in test_cases:
    print(f"ğŸ“¥ è¾“å…¥: {user_input}")
    messages = [{'role': 'user', 'content': user_input}]
    response = list(agent.run(messages))

    # æŸ¥æ‰¾å·¥å…·è°ƒç”¨ç»“æœ
    parsed = None
    for msg in response:
        if msg.get('role') == 'function' and msg.get('name') == 'parse_swap_intent':
            parsed = json.loads(msg['content'])
            break

    if parsed:
        print(f"âœ… è§£æç»“æœ: {parsed}")
    else:
        print("âŒ æœªè°ƒç”¨å·¥å…·æˆ–è§£æå¤±è´¥")

    final_reply = response[-1]['content']
    print(f"ğŸ’¬ Agent å›å¤: {final_reply}\n")
```
<!-- DAILY_CHECKIN_2025-12-03_END -->

# 2025-12-02
<!-- DAILY_CHECKIN_2025-12-02_START -->


### è·‘é€šä¸€ä¸ª Qwen-Agent å®˜æ–¹ç¤ºä¾‹

```
from qwen_agent.agents import Assistant

agent = Assistant()
messages = [{'role': 'user', 'content': 'ä½ å¥½ï¼'}]
response = agent.run(messages)
print(response)
```

### è‡ªå®šä¹‰ä¸€ä¸ªç®€å• Toolï¼Œä¾‹å¦‚ï¼šæŠŠå­—ç¬¦ä¸²è½¬å¤§å†™ï¼›

```
from qwen_agent.tools import BaseTool
from qwen_agent.agents import Assistant
from typing import Dict, Any

# 1. è‡ªå®šä¹‰ Toolï¼šå­—ç¬¦ä¸²è½¬å¤§å†™
class UpperCaseTool(BaseTool):
    name = "upper_case"
    description = "å°†è¾“å…¥çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤§å†™ã€‚"
    parameters: list = [
        {
            "name": "text",
            "type": "string",
            "description": "éœ€è¦è½¬ä¸ºå¤§å†™çš„åŸå§‹å­—ç¬¦ä¸²",
            "required": True,
        }
    ]

    def _run(self, text: str) -> str:
        return text.upper()

# 2. åˆ›å»º Agent å¹¶æ³¨å†Œå·¥å…·
agent = Assistant(
    llm={'model': 'qwen-max', 'api_key': 'dummy'},  # ä½¿ç”¨ dummy key + mock æ¨¡å¼
    function_list=[UpperCaseTool()]
)

# 3. æ¨¡æ‹Ÿç”¨æˆ·æé—®
messages = [{'role': 'user', 'content': 'è¯·æŠŠ "hello world" è½¬æˆå¤§å†™'}]

# 4. è¿è¡Œï¼ˆè‡ªåŠ¨è°ƒç”¨å·¥å…·ï¼‰
response = agent.run(messages)

# 5. æ‰“å°ç»“æœ
for msg in response:
    print(msg)
```

### ç¡®è®¤ Agent èƒ½è‡ªåŠ¨è°ƒç”¨è¿™ä¸ª Tool å¹¶è¿”å›ç»“æœ

éªŒè¯è„šæœ¬

```
import os
from qwen_agent.tools import BaseTool
from qwen_agent.agents import Assistant

# å¼ºåˆ¶å¯ç”¨ Mock LLMï¼ˆé¿å…å› ç¼ºå°‘ API Key æŠ¥é”™ï¼‰
os.environ["QWEN_AGENT_MOCK_LLM"] = "true"

# === 1. è‡ªå®šä¹‰ Tool ===
class UpperCaseTool(BaseTool):
    name = "upper_case"
    description = "å°†è¾“å…¥çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤§å†™ã€‚"
    parameters = [
        {
            "name": "text",
            "type": "string",
            "description": "éœ€è¦è½¬ä¸ºå¤§å†™çš„åŸå§‹å­—ç¬¦ä¸²",
            "required": True,
        }
    ]

    def _run(self, text: str) -> str:
        return text.upper()

# === 2. åˆ›å»º Agent å¹¶æ³¨å†Œå·¥å…· ===
agent = Assistant(
    llm={'model': 'qwen-max'},  # å®é™…ä¸ä¼šè°ƒç”¨ï¼Œå› ä¸ºå¯ç”¨äº† mock
    function_list=[UpperCaseTool()]
)

# === 3. ç”¨æˆ·æé—®ï¼ˆæ˜ç¡®è§¦å‘å·¥å…·ï¼‰===
messages = [{'role': 'user', 'content': 'è¯·æŠŠ "hello agent" è½¬æˆå¤§å†™'}]

# === 4. è¿è¡Œ Agent ===
response = list(agent.run(messages))

# === 5. éªŒè¯è°ƒç”¨é“¾å’Œç»“æœ ===
print("=== æ‰€æœ‰æ¶ˆæ¯æµ ===")
for i, msg in enumerate(response):
    print(f"[{i}] {msg}")

# æå–æœ€ç»ˆå›ç­”
final_answer = response[-1]['content']
print("\nâœ… æœ€ç»ˆå›ç­”:", final_answer)

# éªŒè¯æ˜¯å¦åŒ…å«æ­£ç¡®ç»“æœ
assert "HELLO AGENT" in final_answer, "âŒ å·¥å…·æœªè¢«æ­£ç¡®è°ƒç”¨æˆ–ç»“æœé”™è¯¯ï¼"
print("âœ… æˆåŠŸï¼Agent è‡ªåŠ¨è°ƒç”¨äº†è‡ªå®šä¹‰ Tool å¹¶è¿”å›äº†æ­£ç¡®ç»“æœã€‚")
```

è¾“å‡º

```
=== æ‰€æœ‰æ¶ˆæ¯æµ ===
[0] {'role': 'assistant', 'content': '', 'function_call': {'name': 'upper_case', 'arguments': '{"text": "hello agent"}'}}
[1] {'role': 'function', 'name': 'upper_case', 'content': 'HELLO AGENT'}
[2] {'role': 'assistant', 'content': 'è½¬æ¢ç»“æœæ˜¯ï¼šHELLO AGENT'}

âœ… æœ€ç»ˆå›ç­”: è½¬æ¢ç»“æœæ˜¯ï¼šHELLO AGENT
âœ… æˆåŠŸï¼Agent è‡ªåŠ¨è°ƒç”¨äº†è‡ªå®šä¹‰ Tool å¹¶è¿”å›äº†æ­£ç¡®ç»“æœã€‚
```
<!-- DAILY_CHECKIN_2025-12-02_END -->

# 2025-12-01
<!-- DAILY_CHECKIN_2025-12-01_START -->



```
#!/usr/bin/env node
// index.js
require('dotenv').config();
const axios = require('axios');

const API_KEY = process.env.DASHSCOPE_API_KEY;
if (!API_KEY) throw new Error('è¯·å…ˆè®¾ç½® DASHSCOPE_API_KEY');

async function askQwen(prompt) {
  const { data } = await axios.post(
    'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation',
    {
      model: 'qwen-turbo',
      input: { messages: [{ role: 'user', content: prompt }] },
    },
    {
      headers: {
        Authorization: `Bearer ${API_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );
  return data.output.choices[0].message.content;
}

(async () => {
  const prompt = process.argv.slice(2).join(' ') || 'è¯·ç”Ÿæˆä¸€æ®µå¯¹ ZetaChain çš„ä»‹ç»';
  const reply = await askQwen(prompt);
  console.log(reply);
})();
```

\- å†™ä¸€ä¸ªæœ€å°è„šæœ¬ï¼ˆNode.js / Python å‡å¯ï¼‰ï¼š - è¾“å…¥ä¸€æ®µæç¤ºè¯ï¼Œè¯· Qwen ç”Ÿæˆä¸€æ®µå¯¹ ZetaChain çš„ä»‹ç»ã€‚ - åœ¨ç»ˆç«¯æ‰“å°è¿”å›å†…å®¹ã€‚

æ ¸å¿ƒå‚æ•° API\_KEY å’Œ promptï¼ŒAPI\_KEY ä¸ºè¯·æ±‚ token å¯ä»¥ä»é˜¿é‡Œäº‘æ§åˆ¶å°è·å–ï¼Œprompt ä¸ºé—®é¢˜å†…å®¹
<!-- DAILY_CHECKIN_2025-12-01_END -->

# 2025-11-30
<!-- DAILY_CHECKIN_2025-11-30_START -->




### ZRC-20 å’Œæ™®é€š ERC-20 çš„ç›´è§‚åŒºåˆ«ï¼ˆä»å¼€å‘è€…è§†è§’ï¼‰ã€‚

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/15998431520/images/2025-11-30-1764509614632-image.png)

### ä¸¾ä¸€ä¸ªã€Œé€šç”¨èµ„äº§ã€å¯èƒ½çš„åº”ç”¨åœºæ™¯ï¼ˆæ¯”å¦‚è·¨é“¾å‚¨è“„ã€é€šç”¨ NFT é€šè¡Œè¯ç­‰ï¼‰

æˆ‘ç†è§£çš„é€šç”¨èµ„äº§å°±ç±»ä¼¼äºç°å®ä¸­çš„é»„é‡‘ï¼Œæ— è®ºåœ¨å“ªä¸ªå›½å®¶ï¼Œéƒ½å¯ä»¥å…‘æ¢ä¸ºè¯¥å›½å®¶çš„è´§å¸ï¼Œç„¶åç”¨äºæ¶ˆè´¹ã€‚

web3 ä¸­çš„é€šç”¨èµ„äº§ï¼Œè·¨é“¾ DeFi èšåˆå™¨ä¸­çš„ç»Ÿä¸€æŠµæŠ¼å“ï¼Œå½“ä¸€ä¸ªç”¨æˆ·æ‹¥æœ‰é€šç”¨èµ„äº§ï¼Œä»–å¯ä»¥åœ¨ä»¥å¤ªåŠå€Ÿå‡º ETH ï¼Œåœ¨ Arbitrum ä¸Šæä¾›æµåŠ¨æ€§èµšå– LP æ”¶ç›Šï¼Œåœ¨ Omtimism ä¸Šè´¨æŠ¼è·å¾—æ²»ç†å¥–åŠ±ï¼Œæ‰€æœ‰è¿™äº›æ“ä½œèƒŒåç”±é€šç”¨èµ„äº§åè®®è‡ªåŠ¨å¤„ç†è·¨é“¾çŠ¶æ€åŒæ­¥ä¸æ¸…ç®—é£é™©ï¼Œç”¨æˆ·åªéœ€ç®¡ç†ä¸€ä¸ªèµ„äº§å¤´å¯¸ã€‚
<!-- DAILY_CHECKIN_2025-11-30_END -->

# 2025-11-29
<!-- DAILY_CHECKIN_2025-11-29_START -->





è¯·å‡ä¸€å¤©
<!-- DAILY_CHECKIN_2025-11-29_END -->

# 2025-11-28
<!-- DAILY_CHECKIN_2025-11-28_START -->






è¯·å‡ä¸€å¤©
<!-- DAILY_CHECKIN_2025-11-28_END -->

# 2025-11-27
<!-- DAILY_CHECKIN_2025-11-27_START -->







### è‡ªå·±æƒ³åšçš„ç¬¬ä¸€ä¸ª Universal App æƒ³å®ç°çš„â€œæ‰“å° / è®°å½• / ç®€å•é€»è¾‘â€æ˜¯ä»€ä¹ˆ

å®ƒæ˜¯ä¸€ä¸ªè®°å½•ç¬é—´æ„Ÿæ‚Ÿçš„ UApp åº•éƒ¨æœ‰ä¸¤ä¸ª tabï¼Œå‘å¸ƒ & æµè§ˆ,å‘å¸ƒéƒ¨åˆ†æœ‰ä¸€ä¸ªè¾“å…¥æ¡†ï¼Œä¸€ä¸ªä¸Šä¼ æ–‡ä»¶çš„æŒ‰é’®ï¼Œç”¨æˆ·å¯ä»¥æŠŠå½“æ—¶çš„æ„Ÿå—è®°å½•ä¸‹æ¥ï¼Œä¹Ÿå¯ä¸Šä¼ é‚£ä¸ªç¬é—´çš„ç…§ç‰‡ï¼Œç‚¹å‡»æäº¤æŒ‰é’®ï¼Œå°±ä¼šè¢«ç®—æ³•ç¼–è¯‘æˆå›ºå®šé•¿åº¦çš„å“ˆå¸Œå€¼ï¼Œåˆ©ç”¨å¤§æ¨¡å‹çš„èƒ½åŠ›ï¼Œæ ¹æ®ç”¨æˆ·ä¸Šä¼ çš„ä¿¡æ¯ï¼Œç”Ÿæˆä¸€å¼ å›¾ç‰‡ï¼Œç›´è§‚å½¢è±¡çš„è¡¨ç°å‡ºç”¨æˆ·æœ¬æ¬¡ä¸Šä¼ çš„å†…å®¹ï¼ŒæŠŠ hash å€¼èåˆåˆ°å›¾ç‰‡åº•éƒ¨ï¼Œæ ‡è®°ä¸Šæ—¶é—´æ—¥æœŸï¼Œä¸Šä¼ åˆ°åŒºå—é“¾ï¼Œç”Ÿæˆä¸€ä¸ª NFTï¼Œå­˜å…¥ç”¨æˆ·è´¦æˆ·ä¸­ã€‚åƒä¸€ä¸ªè®°å¿†æ–¹å—è¢«æ°¸ä¹…çš„å­˜è´®åœ¨å»ä¸­å¿ƒåŒ–ç½‘ç»œä¸Šï¼Œæ°¸è¿œä¸ä¼šè¢«ç¯¡æ”¹ï¼Œä¹Ÿä¸ä¼šæ¶ˆå¤±ï¼Œä¹Ÿæ²¡æœ‰äººçŸ¥é“æ˜¯è°çš„è®°å¿†æ–¹å—ï¼Œåœ¨ Uapp çš„å¦ä¸€ä¸ªæµè§ˆæ¨¡å—ï¼Œç”¨æˆ·å¯ä»¥æµè§ˆå…¶ä»–äººçš„è®°å¿†æ–¹å—ï¼Œä¸Šä¸‹æ»‘åŠ¨å¯æŸ¥çœ‹ç”±å¤§æ¨¡å‹ç”Ÿæˆçš„ NFT å°é¢ï¼Œå¦‚æœæ„Ÿå…´è¶£å¯ä»¥ç‚¹å‡»æ‰“å¼€æŸ¥çœ‹èƒŒåçš„æ•…äº‹ï¼Œå¯ä»¥ç‚¹èµå’Œè¯„è®ºï¼Œä¼˜ç§€çš„è®°å¿†æ–¹å—å‘å¸ƒè€…ï¼Œä¼šå¾—åˆ°ä¸€å®šé‡çš„ä»£å¸å¥–åŠ±ã€‚

### ä¸ºåç»­çš„ Hello World Demo å†³å®šä¸€ç§å·¥ä½œæµï¼š

-   ä½¿ç”¨ CLI + Hardhat / Foundryï¼Ÿ
    
-   ç”¨æœ¬åœ°é“¾è¿˜æ˜¯æµ‹è¯•ç½‘ï¼Ÿ
    

æˆ‘é€‰æ‹© CLI + Hardhat + æœ¬åœ°é“¾ï¼Œå¯¹å‰ç«¯å‹å¥½ï¼Œå¼€å‘éš¾åº¦å°ï¼Œé¡¹ç›®å‘¨æœŸçŸ­ï¼Œèƒ½å¿«é€Ÿè½åœ°åˆ›æ„ï¼Œåç»­å‘å¸ƒå·¥ä½œé‡ä¹Ÿä¸ç®—å¤ªå¤§ã€‚

Foundry ä½¿ç”¨ `forge` / `cast` è¿è¡Œï¼Œæœ‰é¢å¤–å­¦ä¹ æˆæœ¬ï¼Œä¸å‰ç«¯é›†æˆæ—¶ ABI çš„å¯¼å‡ºã€ç±»å‹ç”Ÿæˆï¼Œä¸å¦‚ Hardhat ç”Ÿæ€æˆç†Ÿã€‚

Hardhat çš„ `console.log` è°ƒè¯•æ˜¯å·¨å¤§ä¼˜åŠ¿ã€‚
<!-- DAILY_CHECKIN_2025-11-27_END -->

# 2025-11-26
<!-- DAILY_CHECKIN_2025-11-26_START -->








### Universal App æ˜¯ä»€ä¹ˆï¼Ÿ

æ ‡å‡†å«ä¹‰æ˜¯ - é€šç”¨åº”ç”¨ï¼Œæ¯”å¦‚åœ¨è‹¹æœç”Ÿæ€ä¸­ï¼Œä¸€ä¸ª App å¯ä»¥åœ¨ iPhone ä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯ä»¥åœ¨ iPad æˆ–è€… Mac ä¸­æ­£å¸¸ä½¿ç”¨ï¼Œä¸ä¼šå› ä¸ºè¿è¡Œç«¯çš„ä¸åŒè€Œæ— æ³•è¿è¡Œï¼Œé‚£ä¹ˆè¿™ä¸ª App å°±æ˜¯ Universal App ã€‚

åœ¨ web3 ä¸­åˆ™ä»£è¡¨ï¼Œç”¨æˆ·å¯ä¸“æ³¨äº Dapp çš„åŠŸèƒ½ï¼Œè€Œæ— éœ€å…³å¿ƒç¹ççš„ç½‘ç»œåˆ‡æ¢ï¼Œç™»å½•çŠ¶æ€åˆ‡æ¢ï¼ŒåŒºå—é“¾çš„åˆ‡æ¢ï¼Œç¬¦åˆè¿™æ ·éœ€æ±‚çš„ Dapp, å°±å¯ä»¥ç§°ä¹‹ä¸º Universal App ã€‚

### Gateway å¤§æ¦‚åšä»€ä¹ˆï¼Ÿ

æ ‡å‡†å«ä¹‰æ˜¯ - ç½‘å…³ï¼Œæ¯”å¦‚å±€åŸŸç½‘å’Œäº’è”ç½‘çš„é“¾æ¥ï¼Œè·¯ç”±å™¨å°±æ˜¯ Gateway ã€‚

åœ¨ web3 ä¸­åˆ™ä»£è¡¨ï¼Œè¿æ¥å»ä¸­å¿ƒåŒ–åº•å±‚å¹¶æä¾›æœåŠ¡ç»™ä¸Šå±‚è°ƒç”¨ï¼Œä½¿å¼€å‘è€…èƒ½åƒè°ƒç”¨æ™®é€š API ä¸€æ ·ï¼Œè½»æ¾ä½¿ç”¨å»ä¸­å¿ƒåŒ–ç½‘ç»œã€‚

### ç”»ä¸€å¼ ç®€å•çš„æ¶æ„å›¾ï¼š

> ZetaChain ä¸­å¿ƒ + Bitcoin / Ethereum / Solana ç­‰å¤–å›´é“¾ + Gatewayã€‚

ZetaChain æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ L1 åŒºå—é“¾ï¼Œåƒä¸€ä¸ªæ¢çº½èšåˆäº† Ethereumã€Bitcoin ç­‰æ ¸å¿ƒé“¾ï¼Œé€šè¿‡ Getaway ä½œä¸ºå‡ºå…¥å£å‘å¼€å‘è€…æä¾›ä¾¿åˆ©çš„ä¸å»ä¸­å¿ƒåŒ–ç½‘ç»œä¹‹é—´çš„äº¤äº’ã€‚

![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/15998431520/images/2025-11-26-1764169481349-image.png)
<!-- DAILY_CHECKIN_2025-11-26_END -->

# 2025-11-25
<!-- DAILY_CHECKIN_2025-11-25_START -->









## å®‰è£…æˆ–å°è¯•ä½¿ç”¨ ZetaChain CLIï¼ˆæœ¬åœ°æˆ–äº‘ç«¯ç¯å¢ƒå‡å¯ï¼‰ã€‚âœ…

## äº†è§£æµ‹è¯•ç½‘ RPCã€Faucetã€Explorer çš„å…¥å£ï¼Œè®°å½•åœ¨è‡ªå·±çš„ç¬”è®°ä¸­ã€‚âœ…

| ç»„ä»¶ | åœ°å€ / ç”¨æ³• | å¤‡æ³¨ |

| -------- | -------------------------------------------------------- | ---------------------------- |

| RPC | <[https://api.testnet.solana.com](https://api.testnet.solana.com)\> | å•èŠ‚ç‚¹ï¼Œå®˜æ–¹é™é€Ÿï¼š10 s å†…å• IPâ‰¤100 æ¬¡è¯·æ±‚ |

| CLI é…ç½® | solana config set --url <[https://api.testnet.solana.com](https://api.testnet.solana.com)\> | ä¸€é”®åˆ‡æ¢ |

| Faucet | å†…ç½®åœ¨ CLI æˆ– <[https://faucet.solana.com](https://faucet.solana.com)\> | æ¯æ¬¡é¢† 1 aSOLï¼Œæ—  ETH é—¨æ§› |

| Explorer | <[https://explorer.solana.com?cluster=testnet](https://explorer.solana.com?cluster=testnet)\> | å³ä¸Šè§’æ‰‹åŠ¨åˆ‡â€œTestnetâ€å³å¯ |

## åœ¨ç»ˆç«¯æˆ– Postman é‡Œå®Œæˆä¸€æ¬¡ Qwen API çš„ç®€å•è¯·æ±‚ï¼ˆå“ªæ€•åªæ˜¯ 200 æŠ¥é”™ä¹Ÿå¯ä»¥ï¼Œå…ˆæ‰“é€šè¿é€šæ€§ï¼‰ã€‚âœ…

![image.png](https://cdn.nlark.com/yuque/0/2025/png/39084330/1764063123010-189ab11c-a4a8-4ae4-909e-d854352a34bb.png?x-oss-process=image%2Fformat%2Cwebp)![image.png](https://raw.githubusercontent.com/IntensiveCoLearning/Universal-AI/main/assets/15998431520/images/2025-11-25-1764083629753-image.png)
<!-- DAILY_CHECKIN_2025-11-25_END -->

# 2025-11-24
<!-- DAILY_CHECKIN_2025-11-24_START -->










## day1 ä»»åŠ¡

-   æ³¨å†Œ / é…ç½®å¥½ ZetaChain å¼€å‘æ‰€éœ€ç¯å¢ƒï¼ˆæµè§ˆ Docsï¼Œç¡®è®¤èƒ½è®¿é—® Developers é¡µé¢ï¼‰ã€‚
    
-   æ³¨å†Œ Qwen è´¦å·å¹¶ç¡®è®¤å¯ä»¥è¿›å…¥æ§åˆ¶å°ã€‚
    
-   åŠ å…¥ ZetaChain ä¸­å›½å¼€å‘è€…ç¤¾åŒºï¼Œå¾®ä¿¡ï¼šarainqinqinï¼ˆå¤‡æ³¨ï¼šé€šç”¨ AIï¼‰ã€‚
    

### ZetaChain å¼€å‘ç¯å¢ƒ âœ…

npx zetachain@latest new --project hello âœ… å®‰è£…è„šæ‰‹æ¶

cd hello âœ… è¿›å…¥å·¥ç¨‹

yarn âœ… å®‰è£…ä¾èµ–

forge soldeer update âœ… éœ€è¦å®‰è£…ä¸‹ foundry

### æ³¨å†Œ Qwen è´¦å·å¹¶ç¡®è®¤å¯ä»¥è¿›å…¥æ§åˆ¶å°

Python 3.10 âœ…

modelscope å®‰è£…ä¸­.. è²Œä¼¼æœ€å°è¦ 16G ç¼“å­˜ï¼Œæˆ‘çš„ mac ç›®å‰åªæœ‰ 8G

transformers

### ZetaChain ä¸­å›½å¼€å‘è€…ç¤¾åŒº âœ…

å·²æ·»åŠ 
<!-- DAILY_CHECKIN_2025-11-24_END -->
<!-- Content_END -->
